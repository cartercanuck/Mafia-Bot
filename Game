package Mafia_Main_Build;

import java.util.*;

import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.Permission;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.entities.TextChannel;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.events.message.guild.GuildMessageReceivedEvent;
import net.dv8tion.jda.api.events.message.guild.react.GuildMessageReactionAddEvent;
import net.dv8tion.jda.api.events.message.priv.PrivateMessageReceivedEvent;
import net.dv8tion.jda.api.hooks.ListenerAdapter;

public class Game_Config extends ListenerAdapter {

	// important user info
	private User Host;
	private TextChannel channel;
	private TextChannel mafia;
	private TextChannel vampire;

	// player info
	private int numPlayers;
	private User[] players;
	private Member[] members;
	private String[] names;

	// actions info
	private int[][] playerActions;
	private int[] roleList;
	private int[] voteList;
	private int[] counterList;
	private int[] List;
	private int[] LoopList;
	private int[] TargetList;

	// saved reactions
	private String reactionDe = "‚ò†";
	private String reactionBr = "üíî";
	private String reactionBl = "üí´";
	private String reactionNd = "üëå";
	private String reactionWi = "üéâ";
	private String reactionHe = "üõ°";
	private String reactionKK = "‚ùó";
	private String reactionTM = "‚Ñ¢";

	// boolean markers
	private Boolean game = false;
	private Boolean mode = false;
	private Boolean setup = false;
	private Boolean joining = false;
	private Boolean deal = false;
	private Boolean list = false;
	private Boolean night = false;
	private Boolean vote = false;
	private Boolean winner = false;

	// counters
	private int Cr = 1;
	private int SelectedMode = 0;
	private int dead = 0;
	private int Link = 1;

	// this is where the bot gets commands from the main channel
	@Override
	public void onGuildMessageReceived(GuildMessageReceivedEvent event) {
		// ignore bots
		if (event.getAuthor().isBot())
			return;
		String[] args = event.getMessage().getContentRaw().split("\\s+");

		// starting point, checks that no game is currently running
		if ((args[0].equalsIgnoreCase("$start")) && (game == false)) {
			if (args.length < 2) {
				// in case input is incorrect
				event.getChannel().sendTyping().queue();
				event.getChannel().sendMessage("Error, please add the number of players after \"$start\".").queue();
				return;
			}
			try {
				// in case input is incorrect
				@SuppressWarnings("unused")
				int o = Integer.parseInt(args[1]);
			} catch (NumberFormatException hmm) {
				channel.sendMessage("Error, incorrect input.").queue();
				return;
			}
			// saves hosts ID as well as channel for further use
			Host = event.getAuthor();
			channel = event.getChannel();
			mafia = event.getGuild().getTextChannelById("775833141302001665");
			vampire = event.getGuild().getTextChannelById("775833596253962271");
			String P = args[1];
			// sends info to initialize game
			GameStart(P);
			return;
		}
		// specific role setup, checks that the game is in setup mode
		else if ((args[0].equalsIgnoreCase("$mode")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (mode != false)) {
			PickMode(args);
			return;
		}
		// specific role setup, checks that the game is in setup mode
		else if ((args[0].equalsIgnoreCase("$add")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (setup != false)) {
			CustomAdd(args);
			return;
		}
		// roles are given out
		else if ((args[0].equalsIgnoreCase("$deal")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (deal != false)) {
			GiveRoles();
			night = true;
			// game checks for any promotions, then starts the first night
			CheckUpgrade();
			NightMode();
			TeamList();
			deal = false;

			return;
		}
		// list of current roles
		else if ((args[0].equalsIgnoreCase("$roles")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (list != false)) {
			if (SelectedMode != 5) {
				EmbedBuilder roles = RoleList();
				channel.sendMessage(roles.build()).queue();
			} else
				channel.sendMessage("This command is currently disabled.").queue();
			return;
		}
		// game tells lobby who is still alive
		else if ((args[0].equalsIgnoreCase("$live")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (vote != false)) {
			EmbedBuilder live = LiveList();
			channel.sendMessage(live.build()).queue();
			return;
		}
		// general voting system
		else if ((args[0].equalsIgnoreCase("$vote")) && (channel == (event.getChannel())) && (vote != false)
				&& (args.length > 1)) {
			Votes(args, event);
		}
		// replay with same players
		else if ((args[0].equalsIgnoreCase("$again")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (winner != false)) {
			// for same roles
			deal = true;
			RemoveTeam();
			Cr = 1;
			LoopReset();
			if (SelectedMode == 5)
				SetRandom();
			channel.sendTyping().queue();
			channel.sendMessage("Replay mode selected, please type \"$deal\" to start again").queue();
			return;
		}
		// end game, works at any point by host
		else if ((args[0].equalsIgnoreCase("$done")) && (Host == (event.getAuthor()))
				&& (channel == (event.getChannel())) && (game != false)) {
			game = false;
			setup = false;
			mode = false;
			joining = false;
			deal = false;
			night = false;
			vote = false;
			list = false;
			winner = false;
			RemoveTeam();
			for (int j = 0; j < numPlayers; j++) {
				players[j] = null;
				members[j] = null;
				names[j] = null;
				roleList[j] = 0;
				voteList[j] = 0;
				List[j] = 0;
				counterList[j] = 0;
				LoopList[j] = 0;
				TargetList[j] = 0;
			}
			Cr = 1;
			dead = 0;
			SelectedMode = 0;
			Host = null;
			numPlayers = 0;
			channel.sendTyping().queue();
			channel.sendMessage("Game ended, type \"$start\" with the new number of players so you can play again")
					.queue(message -> message.addReaction(reactionTM).queue());
			channel = null;
			return;
		}
		return;
	}

	// These Functions are for Game Start
	// game start function
	public void GameStart(String P) {
		game = true;
		mode = true;

		numPlayers = Integer.parseInt(P) + 1;
		players = new User[numPlayers];
		members = new Member[numPlayers];
		names = new String[numPlayers];
		roleList = new int[numPlayers];
		List = new int[numPlayers];
		voteList = new int[numPlayers];
		counterList = new int[numPlayers];

		LoopList = new int[numPlayers];
		TargetList = new int[numPlayers];

		playerActions = new int[numPlayers][17];
		// set playerActions[][]
		LoopReset();
		channel.sendTyping().queue();
		channel.sendMessage("A game with " + (numPlayers - 1) + " people has started.").queue();
		EmbedBuilder gamelist = new EmbedBuilder().setTitle("Please select a gamemode from the following:")
				.setDescription("(1) Classic  |  (2) Vampire\n(3) Chaos  |  (4) Custom\n(5) Random")
				.setFooter("Use $mode (number)", null).setColor(0xFFFFFF);
		channel.sendMessage(gamelist.build()).queue();
		return;
	}

	// reset playerActions[][] for starting a match
	public void LoopReset() {
		// 0=role, 1=alive, 2=action, 3=target(1), 4=target(2), 5=charges left,
		// 6=immune?, 7=G-immune?, 8=poison?, 9=doused?, 10=evil?, 11 = framed?,
		// 12 = blocked?, 13 = vote immune?, 14=link num, 15=team, 16=voted
		for (int i = 1; i < numPlayers; i++) {
			playerActions[i][1] = 1; // 0=dead, 1=alive
			playerActions[i][2] = 2; // 2 == do nothing (usually)
			playerActions[i][3] = 0; // default 0
			playerActions[i][4] = 0; // default 0
			playerActions[i][5] = 0; // default 0
			playerActions[i][6] = 0; // 0=false, 1 = basic, 2 = heavy
			playerActions[i][7] = 0; // 0=false, 1 = true
			playerActions[i][8] = 0; // 0=false, 1 = new, 2 = death
			playerActions[i][9] = 0; // 0=false, 1 = true
			playerActions[i][10] = 0; // 0=false, 1 = true
			playerActions[i][11] = 0; // 0=false, 1 = true
			playerActions[i][12] = 0; // 0=false, 1 = true
			playerActions[i][13] = 0; // 0=false, 1 = true
			playerActions[i][14] = 0; // 0=false, else = link number
			playerActions[i][15] = 0; // 0=default, 1 = town, 2 = maf, 3 = selfish-killing, 4 = vamp, 5 =
										// neutral-passive, 6 = neutral-killing
			playerActions[i][16] = 0; // 0=default, 1 = voted
			voteList[i] = 0;
			counterList[i] = 0;
		}
		return;
	}

	// mode is selected and set up
	public void PickMode(String[] args) {
		if (args.length < 2) {
			// in case input is incorrect
			channel.sendTyping().queue();
			channel.sendMessage("Error, please select a mode as shown above.").queue();
			return;
		}
		int M;
		// check for error
		try {
			M = Integer.parseInt(args[1]);
		} catch (NumberFormatException hmm) {
			channel.sendMessage("Error, incorrect input, please select a mode as shown above.").queue();
			return;
		}
		switch (M) {
		case 1:
			// classic
			if (numPlayers < 8) {
				channel.sendMessage("Error, Classic requires at least 8 players, please try another one.").queue();
				return;
			}
			SetClassic();
			list = true;
			joining = true;
			break;
		case 2:
			// vamps
			if (numPlayers < 8) {
				channel.sendMessage("Error, Vampires requires at least 8 players, please try another one.").queue();
				return;
			}
			SetVampire();
			list = true;
			joining = true;
			break;
		case 3:
			// chaos
			if (numPlayers < 5) {
				channel.sendMessage("Error, Chaos requires at least 5 players, please try another one.").queue();
				return;
			}
			SetChaos();
			list = true;
			joining = true;
			break;
		case 4:
			// custom mode
			setup = true;
			channel.sendTyping().queue();
			channel.sendMessage("Please enter the roles you wish to use for this game.").queue();
			channel.sendMessage(
					"To do so, enter \"$add\" then the role ID and the amount of this role (ex: \"$add 1 2\").")
					.queue();
			channel.sendMessage("Go to <#864279761914953759> to see the role IDs and descriptions.").queue();
			break;
		case 5:
			// random mode
			SetRandom();
			// players now enter the game
			channel.sendTyping().queue();
			channel.sendMessage("All roles are entered, please react to this message to join!")
					.queue(message -> message.addReaction(reactionKK).queue());
			list = true;
			joining = true;
			break;
		default:
			// in case input is incorrect
			channel.sendTyping().queue();
			channel.sendMessage("Error, incorrect input, please select a mode as shown above.").queue();
			return;
		}
		SelectedMode = M;
		mode = false;
		return;
	}

	// classic settings function
	public void SetClassic() {
		SetRoles(1, 2, Cr); // civilian x2
		SetRoles(3, 1, Cr); // sheriff
		SetRoles(2, 1, Cr); // doctor
		SetRoles(8, 1, Cr); // analyst
		SetRoles(12, 1, Cr); // GF
		SetRoles(15, 1, Cr); // framer
		SetRoles(20, 1, Cr); // arsonist
		switch (numPlayers) {
		case 8:
			break;
		case 9:
			SetRoles(24, 1, Cr); // jester
			break;
		case 10:
			SetRoles(1, 1, Cr); // civilian
			break;
		case 11:
			SetRoles(14, 1, Cr); // concubine
			break;
		case 12:
			SetRoles(9, 1, Cr); // hunter
			break;
		case 13:
			SetRoles(26, 1, Cr); // parasite
			break;
		default:
			for (int i = 14; i < numPlayers; i++) {
				SetRoles(1, 1, Cr); // civilian
			}
		}
		Cr = 1;
		channel.sendMessage("All roles are entered, please react to this message to join!")
				.queue(message -> message.addReaction(reactionKK).queue());
	}

	// vampire settings function
	public void SetVampire() {
		SetRoles(1, 2, Cr); // civilian x2
		SetRoles(3, 1, Cr); // sheriff
		SetRoles(2, 1, Cr); // doctor
		SetRoles(4, 1, Cr); // vigilante
		SetRoles(18, 1, Cr); // head vampire
		switch (numPlayers) {
		case 6:
			break;
		case 7:
			SetRoles(24, 1, Cr); // jester
			break;
		case 8:
			SetRoles(1, 1, Cr); // civilian
			break;
		case 9:
			SetRoles(19, 1, Cr); // turned vampire
			break;
		case 10:
			SetRoles(10, 1, Cr); // herbalist
			break;
		case 11:
			SetRoles(7, 1, Cr); // dancer
			break;
		case 12:
			SetRoles(28, 1, Cr); // bounty hunter
			break;
		case 13:
			SetRoles(20, 1, Cr); // arsonist
			break;
		default:
			for (int i = 14; i < numPlayers; i++) {
				SetRoles(1, 1, Cr); // civilian
			}
		}
		Cr = 1;
		channel.sendMessage("All roles are entered, please react to this message to join!")
				.queue(message -> message.addReaction(reactionKK).queue());
	}

	// chaos settings function
	public void SetChaos() {
		SetRoles(21, 1, Cr); // serial killer
		SetRoles(20, 1, Cr); // arsonist
		SetRoles(2, 1, Cr); // doctor
		SetRoles(6, 1, Cr); // bus driver
		SetRoles(5, 1, Cr); // veteran
		SetRoles(24, 1, Cr); // jester
		switch (numPlayers) {
		case 6:
			break;
		case 7:
			SetRoles(7, 1, Cr); // dancer
			break;
		case 8:
			SetRoles(26, 1, Cr); // parasite
			break;
		case 9:
			SetRoles(23, 1, Cr); // barman
			break;
		case 10:
			SetRoles(27, 1, Cr); // guardian angel
			break;
		case 11:
			SetRoles(10, 1, Cr); // herbalist
			break;
		case 12:
			SetRoles(28, 1, Cr); // bounty hunter
			break;
		case 13:
			SetRoles(12, 1, Cr); // gf
			break;
		default:
			for (int i = 14; i < numPlayers; i++) {
				SetRoles(1, 1, Cr); // civilian
			}
		}
		Cr = 1;
		channel.sendMessage("All roles are entered, please react to this message to join!")
				.queue(message -> message.addReaction(reactionKK).queue());

	}

	// custom match options
	public void CustomAdd(String[] args) {
		int R, N;
		// if no number specified, it assumes 1 by default
		if (args.length <= 2) {
			// check for error
			try {
				R = Integer.parseInt(args[1]);
				N = 1;
			} catch (NumberFormatException hmm) {
				channel.sendMessage("Error, incorrect input(s).").queue();
				return;
			}
		} else {
			// check for error
			try {
				R = Integer.parseInt(args[1]);
				N = Integer.parseInt(args[2]);
			} catch (NumberFormatException hmm) {
				channel.sendMessage("Error, incorrect input(s).").queue();
				return;
			}
		}
		if ((R == 6) || (R == 12) || (R == 13) || (R == 18) || (R == 22)) {
			if (N > 1) {
				// in case incorrect input
				channel.sendTyping().queue();
				channel.sendMessage("Error, this role is a unique role, plese try again.").queue();
				return;
			}
			for (int i = 1; i < numPlayers; i++) {
				if (roleList[i] == R) {
					// in case input is incorrect
					channel.sendTyping().queue();
					channel.sendMessage("Error, this unique role is already in the game, please try again.").queue();
					return;
				}
			}
		}
		if ((numPlayers - Cr) >= N) {
			// lets host know that addition worked, and how many spots are left
			channel.sendTyping().queue();
			channel.sendMessage(N + " " + GetRole(R, 0) + "(s) has/have been added to the game.").queue();
			SetRoles(R, N, Cr);

			if (!(Cr == numPlayers)) {
				channel.sendTyping().queue();
				channel.sendMessage((numPlayers - Cr)
						+ " roles left to enter.\nGo to <#864279761914953759> to see the role IDs and descriptions.")
						.queue();
			} else {
				// if roles are all entered, next step is unlocked
				Cr = 1;
				channel.sendMessage("All roles are entered, please react to any message to join!")
						.queue(message -> message.addReaction(reactionKK).queue());
				setup = false;
				joining = true;
				list = true;
			}
		} else {
			// in case input is incorrect
			channel.sendMessage("You only have " + (numPlayers - Cr) + " roles left to enter, please try again.")
					.queue();
		}
		return;
	}

	// random settings function
	public void SetRandom() {
		int[] tempA = new int[(numPlayers)];
		for (int i = 1; i < numPlayers; i++) {
			tempA[i] = 0;
		}
		int x = 69, r = 1;
		do {
			tempA[r] = (int) (Math.random() * 28) + 1;
			// checks for unique roles
			if ((tempA[r] == 6) || (tempA[r] == 12) || (tempA[r] == 13) || (tempA[r] == 18) || (tempA[r] == 22)) {
				int v = 0;
				for (int i = 1; i < numPlayers; i++) {
					if ((tempA[i] == tempA[r]) && (i != r)) {
						v = 1;
						tempA[r] = 0;
					}
				}
				if (v == 0)
					r++;
			} else
				r++;
			// ends loop is role list is full
			if (tempA[numPlayers - 1] != 0)
				x = 420;
		} while (x == 69);
		// transfers list
		for (int i = 1; i < numPlayers; i++) {
			List[i] = tempA[i];
		}
		// debug to test after new character patch
		/*
		 * setup=true; for(int i=1;i<numPlayers;i++) {
		 * event.getChannel().sendMessage(GetRole(roleList[i], 0)).queue(); }
		 * setup=false;
		 */
	}

	// record role function
	public void SetRoles(int R, int N, int c) {
		// adds role R, N times. c is current role count
		for (int i = 1, j = c; i <= N; i++, j++) {
			List[j] = R;
		}
		// calculates remaining amount
		Cr = Cr + N;
		return;
	}

	// players join through reaction function
	@Override
	public void onGuildMessageReactionAdd(GuildMessageReactionAddEvent event) {
		// stop bots
		if (event.getUser().isBot())
			return;
		// joining function
		else if (joining != false) {
			// checks if player has already joined
			for (int i = 1; i < numPlayers; i++) {
				if ((players[i] != null) && (players[i].equals(event.getUser()))) {
					return;
				}
			}
			// adds player to list, then checks if full
			players[Cr] = event.getUser();
			members[Cr] = event.getMember();
			names[Cr] = event.getMember().getEffectiveName();
			channel.sendTyping().queue();
			channel.sendMessage(names[Cr] + " has joined the game.")
					.queue(message -> message.addReaction(reactionWi).queue());
			Cr++;
			if (Cr == numPlayers) {
				joining = false;
				deal = true;
				Cr = 1;
				channel.sendTyping().queue();
				channel.sendMessage("The game is now full, the host must type \"$deal\" to give roles.").queue();
			}
			return;
		}
	}

	// gives roles function
	public void GiveRoles() {
		int[] tempA = new int[(numPlayers - 1)];
		for (int i = 0, j = 1; i < tempA.length; i++, j++) {
			tempA[i] = List[j];
		}
		// roles are given randomly
		Random rand = new Random();
		int temp = 0;
		for (int i = 1; i < tempA.length; i++) {
			int randomIndexToSwap = rand.nextInt(tempA.length);
			temp = tempA[randomIndexToSwap];
			tempA[randomIndexToSwap] = tempA[i];
			tempA[i] = temp;
		}
		for (int i = 0, j = 1; j < numPlayers; i++, j++) {
			roleList[j] = tempA[i];
		}
		// roles are sent to the players
		for (int i = 1; i < numPlayers; i++) {
			playerActions[i][0] = roleList[i];
			SendRole(i, 0);
			int t = i;
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage("Your ID number is: " + t + "."))
					.queue(message -> message.addReaction(reactionKK).queue());
			if ((playerActions[i][15] == 2) || (playerActions[i][15] == 4))
				SendTeam(i);
		}
		int m = 0, v = 0;
		for (int j = 1; j < numPlayers; j++) {
			if ((playerActions[j][15] == 2) && (m == 0)) {
				// divides new game from old messages in the mafia chat
				mafia.sendMessage("-----------------\nNew match has started!").queue();
				m = 1;
			} else if ((playerActions[j][15] == 4) && (v == 0)) {
				// divides new game from old messages in the vamp chat
				vampire.sendMessage("-----------------\nNew match has started!").queue();
				v = 1;
			}
			if ((m == 1) && (v == 1))
				break;
		}
		channel.sendTyping().queue();
		channel.sendMessage("Every player should now have a role.").queue();
	}

	// These Functions are for once the Game is Going
	// give teams function
	public void SendTeam(int Origin) {
		// gives mafia their chat (mafia.getMembers().contains(members[i]) == false)
		if (playerActions[Origin][15] == 2) {
			mafia.upsertPermissionOverride(members[Origin]).grant(Permission.VIEW_CHANNEL).queue();
			players[Origin].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("You were added to the mafia chat <#775833141302001665>."))
					.queue();
		}
		// gives vampires their chat
		else if (playerActions[Origin][15] == 4) {
			vampire.upsertPermissionOverride(members[Origin]).grant(Permission.VIEW_CHANNEL).queue();
			players[Origin].openPrivateChannel()
					.flatMap(
							channel -> channel.sendMessage("You were added to the vampire chat <#775833596253962271>."))
					.queue();
		}
		return;
	}

	// take teams function
	public void RemoveTeam() {
		for (int i = 1; i < numPlayers; i++) {
			// removes mafia chat (mafia.getMembers().contains(members[i]) != false)
			if (playerActions[i][15] == 2) {
				mafia.upsertPermissionOverride(members[i]).deny(Permission.VIEW_CHANNEL).queue();
			} else if (playerActions[i][15] == 4) {
				vampire.upsertPermissionOverride(members[i]).deny(Permission.VIEW_CHANNEL).queue();
			}
		}
		return;
	}

	// send night announcement and check who has actions
	public void NightMode() {
		channel.sendTyping().queue();
		channel.sendMessage("Night is starting, everyone must send me their actions privately.").queue();
		// moon stuff (0 = active)
		int moon = 0;
		if (deal != true) {
			int c = 0;
			// check live players, if below 1/3 left, moon every night
			for (int i = 1; i < numPlayers; i++) {
				if (playerActions[i][1] == 1)
					c++;
			}
			if (c <= ((numPlayers - 1) / 2)) {
				moon = 0;
			} else
				moon = (int) (Math.random() * (3));
		} else
			moon = 1;
		for (int i = 1; i < numPlayers; i++) {
			int p = 0;
			// records which players dont need to do anything
			if ((playerActions[i][0] == 1) || (playerActions[i][0] == 9) || (playerActions[i][0] == 17)
					|| (playerActions[i][0] == 19) || (playerActions[i][0] == 24) || (playerActions[i][0] == 28)
					|| (playerActions[i][1] == 0)) {
				roleList[i] = 0;
			}
			// GA
			if ((playerActions[i][0] == 27) && (playerActions[i][5] != 0)) {
				roleList[i] = 1;
			}
			// once actions are all used
			if ((playerActions[i][0] == 4) || (playerActions[i][0] == 5) || (playerActions[i][0] == 16)
					|| (playerActions[i][0] == 18) || (playerActions[i][0] == 26) || (playerActions[i][0] == 27)) {
				if (playerActions[i][5] == 0)
					roleList[i] = 0;
				else
					p = 1;
			}
			// records if jester is active
			if ((playerActions[i][0] == 24) && (playerActions[i][1] == 0) && (playerActions[i][5] == 2)) {
				roleList[i] = 1;
			}
			// checks if ww can attack or not
			if ((moon != 0) && (playerActions[i][0] == 22)) {
				roleList[i] = 0;
				players[i].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("It is not a full moon tonight.")).queue();
			}
			// stops vigilante from attacking night 1
			if ((playerActions[i][0] == 4) && (deal == true)) {
				roleList[i] = 0;
			}
			// stops amnesiac from night 1
			if ((playerActions[i][0] == 25) && (deal == true)) {
				roleList[i] = 0;
			}
			// updates polling officer for a new night
			if (playerActions[i][0] == 11) {
				playerActions[i][2] = 2;
			}
			// game tells inactive people they have nothing to do
			if (roleList[i] == 0) {
				players[i].openPrivateChannel()
						.flatMap(
								channel -> channel.sendMessage("You have no actions to take, the night will end soon."))
						.queue();
			}
			// tells active people (and ga) to do their thing
			else {
				players[i].openPrivateChannel()
						.flatMap(channel -> channel
								.sendMessage("Please enter your action now.\n(Type \"$help\" to see all commands)"))
						.queue();
				if (playerActions[i][0] == 24)
					players[i].openPrivateChannel().flatMap(
							channel -> channel.sendMessage("Use \"$do 1 #\" where # is the person you wish to kill."))
							.queue();
				// tell people how many actions they have left
				if (p == 1) {
					int c = i;
					players[i].openPrivateChannel()
							.flatMap(channel -> channel
									.sendMessage("You can use your ability " + playerActions[c][5] + " more times."))
							.queue();
				}
				if (playerActions[i][0] == 25) {
					// tells amne who is dead
					EmbedBuilder dead = DeadList();
					players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(dead.build())).queue();
				} else {
					// tells players who is alive
					EmbedBuilder alive = LiveList();
					players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(alive.build())).queue();
				}
			}
			// full moon
			if (moon == 0) {
				players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage("It is a full moon tonight!"))
						.queue();
				if (playerActions[i][0] == 22)
					playerActions[i][10] = 1;
			}
		}
	}

	// voting function
	public void Votes(String[] args, GuildMessageReceivedEvent event) {
		int v = 0, p = 0, c = 0, kill = 0, max = 0;
		User temp = event.getAuthor();
		// check to see if debug has been activated
		if (!(args[1].equalsIgnoreCase("skip") && (Host == event.getAuthor()))) {
			// checks that the user has the ability to vote (dead or already voted)
			for (int i = 1; i < numPlayers; i++) {
				if ((players[i].equals(temp)) && (playerActions[i][1] != 0) && (playerActions[i][16] == 0)) {
					p = i;
					break;
				}
			}
			if (p == 0)
				return;
			// check input is a number
			try {
				v = Integer.parseInt(args[1]);
			} catch (NumberFormatException hmm) {
				return;
			}
			// in case input is incorrect
			if ((v > 0) && (v < numPlayers) && (playerActions[v][1] != 0) && (playerActions[v][13] == 0)) {
				// records that the user has now voted
				playerActions[p][16] = 1;
				// records how many players are still alive
				for (int j = 1; j < numPlayers; j++) {
					if (playerActions[j][1] == 1) {
						c++;
					}
					// adds a vote slot for polling officer
					if ((playerActions[j][0] == 11) && (playerActions[j][2] != 2)) {
						c++;
					}
				}
				for (int j = 1; j < numPlayers; j++) {
					if (voteList[j] == v) {
						counterList[j]++;
						v = 0;
						channel.sendTyping().queue();
						channel.sendMessage("Thank you for voting.").queue();
						break;
					}
				}
				// if vote target is new, they are added to the poll
				if (v != 0) {
					voteList[Cr] = v;
					counterList[Cr] = 1;
					channel.sendTyping().queue();
					channel.sendMessage("Thank you for voting.").queue();
					v = 0;
				}
				// find when majority vote can happen
				double majLine = 0;
				if ((c % 2) == 0) {
					majLine = (c / 2) + 1;
				} else
					majLine = Math.ceil(c / 2.0);
				// checks for a majority vote or if everyone has voted
				for (int i = 1; i < numPlayers; i++) {
					if (counterList[i] >= majLine) {
						if (counterList[i] > max) {
							max = counterList[i];
							kill = voteList[i];
							v = 1;
						} else if (counterList[i] == max) {
							kill = 0;
							v = 0;
						}
					}
				}
				if ((kill == 0) && (Cr == c))
					v = 1;
				// increases count for next user
				Cr++;
				// if everyone has voted, voting ends and results are calculated
				if (v == 0)
					return;
			} else {
				// in case input is incorrect
				channel.sendTyping().queue();
				channel.sendMessage("Error, attempted to vote off a dead/nonexistant/immune player, try again.")
						.queue();
				return;
			}
		}

		Cr = 1;
		// player with the most votes dies, ties mean no death
		// upon a death, game goes through all the steps
		if (kill != 0) {
			playerActions[kill][1] = 0;
			channel.sendTyping().queue();
			channel.sendMessage(names[kill] + " was voted off by the town!")
					.queue(message -> message.addReaction(reactionDe).queue());
			// checks for a parasite link
			CheckLink(kill);
			// reset a bunch of counters
			for (int j = 1; j < numPlayers; j++) {
				if (playerActions[j][1] == 0)
					roleList[j] = 0;
				else
					playerActions[j][16] = 0;
				playerActions[j][7] = 0;
				voteList[j] = 0;
				counterList[j] = 0;
			}
			// checks for jester
			if (playerActions[kill][0] == 24) {
				channel.sendTyping().queue();
				channel.sendMessage(names[kill] + " was the jester, they won!")
						.queue(message -> message.addReaction(reactionWi).queue());
				playerActions[kill][5] = 2;
			}
			// checks for G.A./bounty hunter update
			for (int i = 1; i < numPlayers; i++) {
				if (playerActions[i][0] == 27) {
					// sets G.A. to jester upon failed task
					if (playerActions[i][3] == kill) {
						players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage("Your target died!"))
								.queue(message -> message.addReaction(reactionKK).queue());
						int target = playerActions[i][3];
						if (playerActions[i][1] != 0) {
							if (playerActions[target][15] == 1) {
								playerActions[i][0] = 1;
								playerActions[i][5] = 0;
								SendRole(i, 0);
								players[i].openPrivateChannel()
										.flatMap(channel -> channel.sendMessage(
												"Your target died! You are now a Civilian as they were town."))
										.queue(message -> message.addReaction(reactionDe).queue());
							} else if (playerActions[target][15] == 2) {
								playerActions[i][0] = 17;
								playerActions[i][5] = 0;
								SendRole(i, 0);
								players[i].openPrivateChannel()
										.flatMap(channel -> channel.sendMessage(
												"Your target died! You are now a Mafia Member as they were mafia."))
										.queue(message -> message.addReaction(reactionDe).queue());
							} else if (playerActions[target][15] == 4) {
								playerActions[i][0] = 19;
								playerActions[i][5] = 0;
								SendRole(i, 0);
								players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(
										"Your target died! You are now a Turned Vampire as they were a vampire."))
										.queue(message -> message.addReaction(reactionDe).queue());
							} else {
								playerActions[i][0] = 24;
								playerActions[i][5] = 0;
								SendRole(i, 0);
								players[i].openPrivateChannel()
										.flatMap(channel -> channel.sendMessage(
												"Your target died! You are now a Jester as they were a neutral role."))
										.queue(message -> message.addReaction(reactionDe).queue());
							}
						}
					}
				}
				// if bounty killed their target
				if (playerActions[i][0] == 28) {
					if (playerActions[i][3] == kill) {
						players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(
								"Your target got voted! You can now do whatever you want, as you have already won."))
								.queue(message -> message.addReaction(reactionDe).queue());
						// to track
						playerActions[i][5] = 1;
					}
				}
			}
			if (CheckHunter() == false) {
				vote = false;
				night = true;
				// checks if game ends
				if (CheckWin() == false) {
					// checks for promotions and updates to players
					CheckUpgrade();
					NightMode();
					TeamList();
					// night starts again, and the cycle repeats
					return;
				}
			}
		}
		// upon no death, etc..
		else {
			channel.sendTyping().queue();
			channel.sendMessage("No one was voted off by the town!")
					.queue(message -> message.addReaction(reactionNd).queue());
			for (int j = 1; j < numPlayers; j++) {
				if (playerActions[j][1] == 0)
					roleList[j] = 0;
				else
					playerActions[j][16] = 0;
				playerActions[j][7] = 0;
				voteList[j] = 0;
				counterList[j] = 0;
			}
			vote = false;
			night = true;
			// checks updates, then night starts again, and the cycle repeats
			NightMode();
			TeamList();
			return;
		}
		return;
	}

	// bot gets private commands here
	@Override
	public void onPrivateMessageReceived(PrivateMessageReceivedEvent event) {
		// stop bots
		if (event.getAuthor().isBot())
			return;
		String[] args = event.getMessage().getContentRaw().split("\\s+");
		// get actions from players function
		if ((args[0].equalsIgnoreCase("$do")) && (night != false)) {
			DoFunction(args, event);
			return;
		}
		// hunter needs to kill function
		else if (args[0].equalsIgnoreCase("$kill")) {
			User user = event.getAuthor();
			for (int i = 1; i < numPlayers; i++) {
				// checks that it is time to kill
				if (user.equals(players[i])) {
					if ((playerActions[i][0] == 9) && (playerActions[i][1] == 0) && (playerActions[i][5] == 1)) {
						int A;
						// general target error catch
						// check for incorrect input
						try {
							A = Integer.parseInt(args[1]);
						} catch (NumberFormatException hmm) {
							user.openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("Error, incorrect target input.")).queue();
							return;
						}
						if ((A <= 0) || (A > numPlayers) || (playerActions[A][1] == 0)) {
							user.openPrivateChannel().flatMap(channel -> channel
									.sendMessage("You cannot target a dead/non-existant person, please try again."))
									.queue();
							return;

						}
						// follow through actions
						user.openPrivateChannel().flatMap(channel -> channel.sendMessage("Action recieved."))
								.queue(message -> message.addReaction(reactionNd).queue());
						if (playerActions[A][7] != 1) {
							playerActions[A][1] = 0;
							playerActions[i][5] = 0;
							players[A].openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("You were shot by a Hunter! You are dead."))
									.queue(message -> message.addReaction(reactionDe).queue());
							channel.sendTyping().queue();
							channel.sendMessage(names[A] + " was shot by a Hunter!")
									.queue(message -> message.addReaction(reactionDe).queue());
							CheckLink(A);
							for (int j = 1; j < numPlayers; j++) {
								if (playerActions[j][1] == 0) {
									playerActions[j][13] = 1;
								}
							}
							CheckUpgrade();
						} else {
							playerActions[i][5] = 0;
							channel.sendTyping().queue();
							channel.sendMessage(names[A]
									+ " was shot by a Hunter, but was saved by their Guardian Angel's blessing!")
									.queue();
							for (int j = 1; j < numPlayers; j++) {
								if (playerActions[j][1] == 0) {
									playerActions[j][13] = 1;
								}
							}
							CheckUpgrade();
						}
						// switch to day/night
						vote = !vote;
						night = !night;
						if (CheckWin() == false) {
							if (vote == true)
								channel.sendMessage("The host can type \"$live\" to see who is still here.").queue();
							else {
								CheckUpgrade();
								NightMode();
							}
						}
					}
				}
			}
			return;
		}
		// to see roles (in private)
		else if ((args[0].equalsIgnoreCase("$roles")) && (list != false)) {
			if (SelectedMode != 5) {
				EmbedBuilder roles = RoleList();
				event.getAuthor().openPrivateChannel().flatMap(channel -> channel.sendMessage(roles.build())).queue();
				return;
			} else
				event.getAuthor().openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("This command is disabled for this mode.")).queue();

		} else if ((args[0].equalsIgnoreCase("$actions")) && (game != false)) {
			User member = event.getAuthor();
			for (int i = 1; i < numPlayers; i++) {
				if (member.equals(players[i])) {
					SendRole(i, 1);
					break;
				}
			}
		}
		// help command for private dms
		else if ((args[0].equalsIgnoreCase("$help")) && (game != false)) {
			EmbedBuilder helper = new EmbedBuilder().setTitle("Help Pannel")
					.setDescription("To send actions, type \"$do\" followed by your action number, then your"
							+ " (first) target. If you have a second target, it follows after.\n(ex:$do 1 3 4)"
							+ "\n\nType \"$actions\" to see the what actions you can take if you can't remember."
							+ "\nType \"$roles\" to see the roles that are in the match.\n Go to #mafia-links for more role info.")
					.setColor(0xFFFFFF);
			event.getAuthor().openPrivateChannel().flatMap(channel -> channel.sendMessage(helper.build())).queue();
		}
	}

	// do function
	public void DoFunction(String[] args, PrivateMessageReceivedEvent event) {
		User user = event.getAuthor();
		int A;
		// check for incorrect input
		try {
			A = Integer.parseInt(args[1]);
			if (A > 4) {
				user.openPrivateChannel().flatMap(channel -> channel.sendMessage("Error, incorrect action input."))
						.queue();
				return;
			}
			if (A < 1) {
				user.openPrivateChannel().flatMap(channel -> channel.sendMessage("Error, incorrect action input."))
						.queue();
				return;
			}
		} catch (NumberFormatException hmm) {
			user.openPrivateChannel().flatMap(channel -> channel.sendMessage("Error, incorrect action input.")).queue();
			return;
		}
		// giant checker to make sure the player didnt mess up
		for (int i = 1; i < numPlayers; i++) {
			if (user.equals(players[i])) {
				if ((playerActions[i][1] == 0) && (playerActions[i][0] != 24) && (playerActions[i][0] != 27)) {
					user.openPrivateChannel().flatMap(channel -> channel.sendMessage("You are dead.")).queue();
					return; // stops dead people
				}
				if (roleList[i] == 0) {
					user.openPrivateChannel()
							.flatMap(channel -> channel.sendMessage(
									"You dont have any actions, please just wait patiently for the night to end."))
							.queue();
					AllReady(event);
					return; // stops people who don't have actions
				}
				playerActions[i][2] = A;
				// checks first input slot for if they can skip night
				if ((playerActions[i][2] == 2) && (playerActions[i][0] != 10) && (playerActions[i][0] != 20)
						&& (playerActions[i][0] != 22)) {
					// Parasite must link to someone night 1
					if ((playerActions[i][0] == 26) && (playerActions[i][5] == 1)) {
						players[i].openPrivateChannel().flatMap(channel -> channel
								.sendMessage("Error, the Parasite must link to someone on night one.")).queue();
						return;
					}
					// Jester must kill after being hanged
					if ((playerActions[i][0] == 24) && (playerActions[i][5] == 2)) {
						players[i].openPrivateChannel().flatMap(channel -> channel
								.sendMessage("Error, the Jester must kill someone after being voted by the town."))
								.queue();
						return;
					}
					user.openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Action recieved, the night will end soon."))
							.queue(message -> message.addReaction(reactionNd).queue());
					AllReady(event);
					// notify teams of what a member is doing
					if (playerActions[i][15] == 2) {
						mafia.sendTyping().queue();
						mafia.sendMessage(names[i] + " is staying home.").queue();
					} else if (playerActions[i][15] == 4) {
						vampire.sendTyping().queue();
						vampire.sendMessage(names[i] + " is staying home.").queue();
					}
					return;
				}
				// checks first input slot for if they can skip (specific characters)
				if (playerActions[i][2] == 3) {
					if ((playerActions[i][0] == 10) || (playerActions[i][0] == 20) || (playerActions[i][0] == 22)) {
						user.openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("Action recieved, the night will end soon."))
								.queue(message -> message.addReaction(reactionNd).queue());
						AllReady(event);
						return;
					}
				}
				// arso igniting and ww ambushing
				if ((playerActions[i][0] == 20) || (playerActions[i][0] == 22)) {
					if (playerActions[i][2] == 2) {
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("Action recieved, the night will end soon."))
								.queue(message -> message.addReaction(reactionNd).queue());
						AllReady(event);
						return;
					}
				}
				// GA saving their target
				if (playerActions[i][0] == 27) {
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Action recieved, the night will end soon."))
							.queue(message -> message.addReaction(reactionNd).queue());
					AllReady(event);
					return;
				}
				// checks second input slot for if they can target properly
				if (args.length >= 3) {
					//
					try {
						A = Integer.parseInt(args[2]);
						if (A > numPlayers - 1) {
							user.openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("Error, incorrect 1st target input."))
									.queue();
							return;
						}
						if (A < 1) {
							user.openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("Error, incorrect 1st target input."))
									.queue();
							return;
						}
					} catch (NumberFormatException hmm) {
						user.openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("Error, incorrect 1st target input.")).queue();
						return;
					}
					// no dead targets
					if ((playerActions[A][1] == 0) && (playerActions[i][0] != 25)) {
						user.openPrivateChannel().flatMap(
								channel -> channel.sendMessage("You cannot target a dead person, please try again."))
								.queue();
						return;
					}
					// doctor rules
					if (playerActions[i][0] == 2) {
						if (playerActions[i][3] == A) {
							user.openPrivateChannel()
									.flatMap(channel -> channel
											.sendMessage("You cannot heal the same person twice, please try again."))
									.queue();
							return;
						}
					}
					if ((playerActions[i][0] == 26) && (A == i)) {
						players[i].openPrivateChannel()
								.flatMap(
										channel -> channel.sendMessage("Error, the Parasite cannot target themselves."))
								.queue();
						return;
					}
					// analyst rules
					if ((playerActions[i][0] == 8) && (A == i)) {
						user.openPrivateChannel().flatMap(
								channel -> channel.sendMessage("You can not target yourself, please try again."))
								.queue();
						return;
					}
					// amnesiac rules
					if (playerActions[i][0] == 25) {
						// no living players
						if (playerActions[A][1] == 1) {
							user.openPrivateChannel().flatMap(channel -> channel.sendMessage(
									"The player you selected is still alive, please try again with someone else."))
									.queue();
							return;
						}
						if ((playerActions[A][0] == 6) || (playerActions[A][0] == 12) || (playerActions[A][0] == 13)
								|| (playerActions[A][0] == 18) || (playerActions[A][0] == 22)) {
							// checks if unique role is taken
							for (int j = 1; j < numPlayers; j++) {
								if ((playerActions[j][1] == 1) && (playerActions[A][0] == playerActions[j][0])) {
									user.openPrivateChannel()
											.flatMap(channel -> channel.sendMessage("The player you selected is a "
													+ "role that you can not currently become, please try again with someone else."))
											.queue();
									return;
								}
							}
						}
					}
					playerActions[i][3] = A;
					// checks third input slot for if they can target properly
					if ((args.length >= 4) && ((playerActions[i][0] == 6) || (playerActions[i][0] == 8))) {
						// check for incorrect input
						try {
							A = Integer.parseInt(args[3]);
							if (A > numPlayers - 1) {
								user.openPrivateChannel()
										.flatMap(channel -> channel.sendMessage("Error, incorrect 2nd target input."))
										.queue();
								return;
							}
							if (A < 1) {
								user.openPrivateChannel()
										.flatMap(channel -> channel.sendMessage("Error, incorrect 2nd target input."))
										.queue();
								return;
							}
						} catch (NumberFormatException hmm) {
							user.openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("Error, incorrect 2nd target input."))
									.queue();
							return;
						}
						// no dead targets
						if (playerActions[A][1] == 0) {
							user.openPrivateChannel().flatMap(channel -> channel
									.sendMessage("You cannot target a dead person, please try again.")).queue();
							return;
						}
						// analyst rules part 2
						if ((playerActions[i][0] == 8) && (A == i)) {
							user.openPrivateChannel().flatMap(
									channel -> channel.sendMessage("You cannot target yourself, please try again."))
									.queue();
							return;
						}
						if ((playerActions[i][0] == 8) && (playerActions[i][3] == A)) {
							user.openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("You cannot target the same person twice."))
									.queue();
							return;
						}
						playerActions[i][4] = A;
					}
					// these roles need two targets
					else if ((playerActions[i][0] == 6) || (playerActions[i][0] == 8)) {
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("error, please enter "
										+ "a second target value after \"$do\". \nType \"$help\" if you are confused."))
								.queue();
						return;
					}
				}
				// general error message to player
				else if (playerActions[i][0] != 5) {
					players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage("error, please enter "
							+ "a target value after \"$do\". \nType \"$help\" if you are confused.")).queue();
					return;
				}
				// everything worked, the players job is done
				players[i].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("Action recieved, the night will end soon."))
						.queue(message -> message.addReaction(reactionNd).queue());
				AllReady(event);
				// notify teams of what a member is doing
				if (playerActions[i][15] == 2) {
					mafia.sendTyping().queue();
					mafia.sendMessage(names[i] + " targeted " + names[playerActions[i][3]] + ".").queue();
				} else if (playerActions[i][15] == 4) {
					vampire.sendTyping().queue();
					vampire.sendMessage(names[i] + " targeted " + names[playerActions[i][3]] + ".").queue();
				}
				return;
			}
		}
	}

	// all actions received function
	public void AllReady(PrivateMessageReceivedEvent event) {
		User user = event.getAuthor();
		// records that they did their action
		for (int i = 1; i < numPlayers; i++) {
			if (user.equals(players[i])) {
				roleList[i] = 0;
			}
		}
		// stops function if someone hasn't done their action yet
		for (int i = 1; i < numPlayers; i++) {
			if (roleList[i] != 0) {
				return;
			}
		}
		// starts to end the night
		for (int i = 1; i < numPlayers; i++) {
			if (playerActions[i][1] == 1) {
				players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage("The day has started!")).queue();
			}
		}
		// reset actions for later
		for (int i = 1; i < numPlayers; i++) {
			if ((playerActions[i][1] != 0) || (playerActions[i][0] == 27))
				roleList[i] = 1;
		}
		channel.sendTyping().queue();
		channel.sendMessage("All living players are ready, let the day begin!").queue();
		channel.sendMessage("---------------------------------").queue();
		// tells math function to start
		Math();
		// checks if hunter died
		if (CheckHunter() == false) {
			vote = true;
			night = false;
			// checks if the game is over
			if (CheckWin() == false)
				channel.sendMessage("The host can type the following commands:\n\"$live\" to see who is still here."
						+ "\n\"$roles\" to see the current role list.\nAnyone can now "
						+ "also vote with \"$vote #\" where # is their target.").queue();
		}
	}

	// check for a win function
	public boolean CheckWin() {
		int team = 0;
		for (int i = 1; i < numPlayers; i++) {
			if (playerActions[i][1] == 1) {
				team = playerActions[i][15];
				// loop for town
				if (team == 1) {
					for (int j = 1; j < numPlayers; j++) {
						if (playerActions[j][1] == 1) {
							if (!((playerActions[j][15] == 1) || (playerActions[j][15] == 5)))
								return false;
						}
					}
					// if loop gets here, town have won the game
					channel.sendTyping().queue();
					channel.sendMessage("---------------------------------").queue();
					channel.sendMessage("Town win the game!").queue(message -> message.addReaction(reactionWi).queue());
					for (int k = 1; k < numPlayers; k++) {
						// check for GA win
						if ((playerActions[k][0] == 27) && (playerActions[playerActions[k][3]][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Guardian Angel! Their target was: "
									+ players[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check for Parasite win
						if ((playerActions[k][0] == 26) && (playerActions[k][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Parasite!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check bounty hunter win
						if ((playerActions[k][0] == 28) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " wins as a Bounty Hunter! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check jester win
						if ((playerActions[k][0] == 24) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " won as a Jester!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
					}
					channel.sendMessage("The host may enter either \"$again\" to play with the same players, "
							+ "or \"$done\" to end the match.").queue();
					winner = true;
					night = false;
					vote = false;
					return true;
				}
				// loop for mafia
				else if (team == 2) {
					for (int j = 1; j < numPlayers; j++) {
						if (playerActions[j][1] == 1) {
							if (!((playerActions[j][15] == 2) || (playerActions[j][15] == 5)
									|| (playerActions[j][15] == 6)))
								return false;
						}
					}
					// if loop gets here, mafia have won the game
					channel.sendTyping().queue();
					channel.sendMessage("---------------------------------").queue();
					channel.sendMessage("Mafia win the game!")
							.queue(message -> message.addReaction(reactionWi).queue());
					for (int k = 1; k < numPlayers; k++) {
						// check for GA win
						if ((playerActions[k][0] == 27) && (playerActions[playerActions[k][3]][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Guardian Angel! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check for Parasite win
						if ((playerActions[k][0] == 26) && (playerActions[k][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Parasite!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						if ((playerActions[k][0] == 28) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " wins as a Bounty Hunter! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check jester win
						if ((playerActions[k][0] == 24) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " won as a Jester!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
					}
					channel.sendMessage("The host may enter either \"$again\" to play with the same players, "
							+ "or \"$done\" to end the match.").queue();
					winner = true;
					night = false;
					vote = false;
					return true;
				}
				// loop for selfish killings
				else if (team == 3) {
					for (int j = 1; j < numPlayers; j++) {
						if (playerActions[j][1] == 1) {
							if ((playerActions[j][15] == 1) || (playerActions[j][15] == 2)
									|| (playerActions[j][15] == 4))
								return false;
							// only wins with other selfish killing of same class
							if ((playerActions[j][15] == 3) && (playerActions[j][0] != playerActions[i][0])) {
								return false;
							}
						}
					}
					// if loop gets here, they have won the game
					channel.sendTyping().queue();
					channel.sendMessage("---------------------------------").queue();
					channel.sendMessage(GetRole(i, 1) + " win the game!")
							.queue(message -> message.addReaction(reactionWi).queue());
					for (int k = 1; k < numPlayers; k++) {
						// check for GA win
						if ((playerActions[k][0] == 27) && (playerActions[playerActions[k][3]][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Guardian Angel! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check for Parasite win
						if ((playerActions[k][0] == 26) && (playerActions[k][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Parasite!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						if ((playerActions[k][0] == 28) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " wins as a Bounty Hunter! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check jester win
						if ((playerActions[k][0] == 24) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " won as a Jester!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
					}
					channel.sendMessage("The host may enter either \"$again\" to play with the same players, "
							+ "or \"$done\" to end the match.").queue();
					winner = true;
					night = false;
					vote = false;
					return true;
				}
				// loop for vampires
				else if (team == 4) {
					for (int j = 1; j < numPlayers; j++) {
						if (playerActions[j][1] == 1) {
							if (!((playerActions[j][15] == 4) || (playerActions[j][15] == 5)
									|| (playerActions[j][15] == 6)))
								return false;
						}
					}
					// if loop gets here, vampires have won the game
					channel.sendTyping().queue();
					channel.sendMessage("---------------------------------").queue();
					channel.sendMessage("Vampires win the game!")
							.queue(message -> message.addReaction(reactionWi).queue());
					for (int k = 1; k < numPlayers; k++) {
						// check for GA win
						if ((playerActions[k][0] == 27) && (playerActions[playerActions[k][3]][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Guardian Angel! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check for Parasite win
						if ((playerActions[k][0] == 26) && (playerActions[k][1] == 1)) {
							channel.sendMessage(names[k] + " wins as a Parasite!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						if ((playerActions[k][0] == 28) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " wins as a Bounty Hunter! Their target was: "
									+ names[playerActions[k][3]])
									.queue(message -> message.addReaction(reactionWi).queue());
						}
						// check jester win
						if ((playerActions[k][0] == 24) && (playerActions[k][5] == 1)) {
							channel.sendMessage(names[k] + " won as a Jester!")
									.queue(message -> message.addReaction(reactionWi).queue());
						}
					}
					channel.sendMessage("The host may enter either \"$again\" to play with the same players, "
							+ "or \"$done\" to end the match.").queue();
					winner = true;
					night = false;
					vote = false;
					return true;
				}
			}
		}
		// if only neutrals remain
		for (int i = 1; i < numPlayers; i++) {
			if (playerActions[i][16] == 6) {
				channel.sendTyping().queue();
				channel.sendMessage("---------------------------------").queue();
				channel.sendMessage("Neutral Killing win the game!")
						.queue(message -> message.addReaction(reactionWi).queue());
				for (int k = 1; k < numPlayers; k++) {
					// check for GA win
					if ((playerActions[k][0] == 27) && (playerActions[playerActions[k][3]][1] == 1)) {
						channel.sendMessage(
								names[k] + " wins as a Guardian Angel! Their target was: " + names[playerActions[k][3]])
								.queue(message -> message.addReaction(reactionWi).queue());
					}
					// check for Parasite win
					if ((playerActions[k][0] == 26) && (playerActions[k][1] == 1)) {
						channel.sendMessage(names[k] + " wins as a Parasite!")
								.queue(message -> message.addReaction(reactionWi).queue());
					}
					if ((playerActions[k][0] == 28) && (playerActions[k][5] == 1)) {
						channel.sendMessage(
								names[k] + " wins as a Bounty Hunter! Their target was: " + names[playerActions[k][3]])
								.queue(message -> message.addReaction(reactionWi).queue());
					}
					// check jester win
					if ((playerActions[k][0] == 24) && (playerActions[k][5] == 1)) {
						channel.sendMessage(names[k] + " won as a Jester!")
								.queue(message -> message.addReaction(reactionWi).queue());
					}
				}
				channel.sendMessage("The host may enter either \"$again\" to play with the same players, "
						+ "or \"$done\" to end the match.").queue();
				winner = true;
				night = false;
				vote = false;
				return true;
			}
		}
		channel.sendTyping().queue();
		channel.sendMessage("---------------------------------").queue();
		channel.sendMessage("No teams are left to win the game.")
				.queue(message -> message.addReaction(reactionDe).queue());
		for (int k = 1; k < numPlayers; k++) {
			// check for GA win
			if ((playerActions[k][0] == 27) && (playerActions[playerActions[k][3]][1] == 1)) {
				channel.sendMessage(
						names[k] + " wins as a Guardian Angel! Their target was: " + names[playerActions[k][3]])
						.queue(message -> message.addReaction(reactionWi).queue());
			}
			// check for Parasite win
			if ((playerActions[k][0] == 26) && (playerActions[k][1] == 1)) {
				channel.sendMessage(names[k] + " wins as a Parasite!")
						.queue(message -> message.addReaction(reactionWi).queue());
			}
			if ((playerActions[k][0] == 28) && (playerActions[k][5] == 1)) {
				channel.sendMessage(
						names[k] + " wins as a Bounty Hunter! Their target was: " + names[playerActions[k][3]])
						.queue(message -> message.addReaction(reactionWi).queue());
			}
			// check jester win
			if ((playerActions[k][0] == 24) && (playerActions[k][5] == 1)) {
				channel.sendMessage(names[k] + " won as a Jester!")
						.queue(message -> message.addReaction(reactionWi).queue());
			}
		}
		channel.sendMessage("The host may enter either \"$again\" to play with the same players, "
				+ "or \"$done\" to end the match.").queue();
		winner = true;
		night = false;
		vote = false;
		return true;
	}

	// check for upgrades function
	public void CheckUpgrade() {
		int HV = 0, GF = 0, Maf = 0;
		// this loop finds out who is alive
		for (int j = 1; j < numPlayers; j++) {
			// Head Vampire
			if ((playerActions[j][0] == 18) && (HV != 2)) {
				if (playerActions[j][1] == 1) {
					HV = 2;
				} else
					HV = 1;
			}
			// Godfather
			if ((playerActions[j][0] == 12) && (GF != 2)) {
				if (playerActions[j][1] == 1) {
					GF = 2;
				} else
					GF = 1;
			}
			// Mafioso
			if ((playerActions[j][0] == 13) && (Maf != 2)) {
				if (playerActions[j][1] == 1) {
					Maf = 2;
				} else
					Maf = 1;
			}
		}
		// checks for replacement
		for (int i = 1; i < numPlayers; i++) {
			// upgrade basic vamp
			if ((playerActions[i][0] == 19) && (playerActions[i][1] == 1) && (HV != 2)) {
				playerActions[i][0] = 18;
				SendRole(i, 0);
				players[i].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("You were promoted to Head Vampire!"))
						.queue(message -> message.addReaction(reactionNd).queue());
				HV = 2;
			}
			// upgrade mafioso to gf
			if ((playerActions[i][0] == 13) && (playerActions[i][1] == 1) && (GF == 1)) {
				playerActions[i][0] = 12;
				SendRole(i, 0);
				players[i].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("You were promoted to Godfather!"))
						.queue(message -> message.addReaction(reactionNd).queue());
				GF = 2;
				Maf = 1;
			}
			// tells GA the bad news
			if (playerActions[i][0] == 27) {
				int target = playerActions[i][3];
				if (playerActions[target][1] == 0) {
					if (playerActions[target][15] == 1) {
						playerActions[i][0] = 1;
						playerActions[i][5] = 0;
						SendRole(i, 0);
						players[i].openPrivateChannel()
								.flatMap(channel -> channel
										.sendMessage("Your target died! You are now a Civilian as they were town."))
								.queue(message -> message.addReaction(reactionDe).queue());
					} else if (playerActions[target][15] == 2) {
						playerActions[i][0] = 17;
						playerActions[i][5] = 0;
						SendRole(i, 0);
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage(
										"Your target died! You are now a Mafia Member as they were mafia."))
								.queue(message -> message.addReaction(reactionDe).queue());
					} else if (playerActions[target][15] == 4) {
						playerActions[i][0] = 19;
						playerActions[i][5] = 0;
						SendRole(i, 0);
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage(
										"Your target died! You are now a Turned Vampire as they were a vampire."))
								.queue(message -> message.addReaction(reactionDe).queue());
					} else {
						playerActions[i][0] = 24;
						playerActions[i][5] = 0;
						SendRole(i, 0);
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage(
										"Your target died! You are now a Jester as they were a neutral role."))
								.queue(message -> message.addReaction(reactionDe).queue());
					}
				}
			}
			// tells Bounty the bad news
			if (playerActions[i][0] == 28) {
				if ((playerActions[playerActions[i][3]][1] == 0) && (playerActions[i][5] != 1)) {
					playerActions[i][0] = 24;
					SendRole(i, 0);
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Your target died at night! You are now a Jester"))
							.queue(message -> message.addReaction(reactionDe).queue());
				}
			}
		}
		// more complicated upgrades
		for (int i = 1; i < numPlayers; i++) {
			// upgrade basic maf to mafioso
			if ((playerActions[i][0] == 17) && (playerActions[i][1] == 1) && (Maf != 2)) {
				playerActions[i][0] = 13;
				SendRole(i, 0);
				players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage("You were promoted to Mafioso!"))
						.queue(message -> message.addReaction(reactionNd).queue());
				Maf = 2;
				break;
			}
		}
		// more complicated upgrades part 2
		for (int i = 1; i < numPlayers; i++) {
			// upgrade other maf if no basic
			if ((Maf != 2) && (GF != 2)) {
				if ((playerActions[i][0] == 14) || (playerActions[i][0] == 15) || (playerActions[i][0] == 16)) {
					if (playerActions[i][1] == 1) {
						playerActions[i][0] = 13;
						playerActions[i][5] = 0;
						SendRole(i, 0);
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("You were promoted to Mafioso!"))
								.queue(message -> message.addReaction(reactionNd).queue());
						Maf = 2;
						break;
					}
				}
			}
		}
	}

	// These Functions Send Lists
	// send full role list
	public EmbedBuilder RoleList() {
		String list = GetRole(1, 0);
		for (int j = 2; j < numPlayers; j++) {
			list = list + "\n" + GetRole(j, 0);
		}
		EmbedBuilder roles = new EmbedBuilder().setTitle("This game is running the following roles:")
				.setDescription(list).setColor(0xFFFFFF);
		return roles;
	}

	// gives live players function
	public EmbedBuilder LiveList() {
		String list = "";
		for (int j = 1; j < numPlayers; j++) {
			if (playerActions[j][1] == 1) {
				String k = names[j];
				int t = j;
				if (j == 1)
					list = list + k + " (" + t + ")";
				else
					list = list + "\n" + k + " (" + t + ")";
			}
		}
		EmbedBuilder alive = new EmbedBuilder().setTitle("The following people are alive:").setDescription(list)
				.setColor(0xFFFFFF);
		return alive;
	}

	// gives dead players for amnesiac function
	public EmbedBuilder DeadList() {
		String list = "";
		for (int j = 1; j < numPlayers; j++) {
			if (playerActions[j][1] == 0) {
				String k = names[j];
				int t = j;
				if (j == 1)
					list = list + k + " (" + t + ")";
				else
					list = list + "\n" + k + " (" + t + ")";
			}
		}
		EmbedBuilder alive = new EmbedBuilder().setTitle("The following people are dead:").setDescription(list)
				.setColor(0xFFFFFF);
		return alive;
	}

	// gives teams member list function
	public void TeamList() {
		// list all mafia members
		String list = "";
		for (int j = 1; j < numPlayers; j++) {
			if (playerActions[j][15] == 2) {
				String k = "";
				if (playerActions[j][1] == 0)
					k = names[j] + " (" + GetRole(j, 1) + ") [" + j + "] (dead)";
				else
					k = names[j] + " (" + GetRole(j, 1) + ") [" + j + "]";
				if (j == 1)
					list = list + k;
				else
					list = list + "\n" + k;
			}
		}
		// check for mafia
		if (!list.equals("")) {
			EmbedBuilder maf = new EmbedBuilder().setTitle("The following people are in the mafia:")
					.setDescription(list).setColor(0xFFFFFF);
			mafia.sendMessage(maf.build()).queue();
		}
		// list all vampires
		list = "";
		for (int j = 1; j < numPlayers; j++) {
			if (playerActions[j][15] == 4) {
				String k = "";
				if (playerActions[j][1] == 0)
					k = names[j] + " (" + GetRole(j, 1) + ") [" + j + "] (dead)";
				else
					k = names[j] + " (" + GetRole(j, 1) + ") [" + j + "]";
				if (j == 1)
					list = list + k;
				else
					list = list + "\n" + k;
			}
		}
		// check for vampires
		if (!list.equals("")) {
			EmbedBuilder vamp = new EmbedBuilder().setTitle("The following people are vampires:").setDescription(list)
					.setColor(0xFFFFFF);
			vampire.sendMessage(vamp.build()).queue();
		}
		return;
	}

	// These Functions do Calculations
	// math function that figures out what happend
	public void Math() {
		int Swap1 = 0, Swap2 = 0, wolf = 0, wolfT = 0, Loop = 0, T1 = 0, T2 = 0;
		// reset dead counter
		dead = 0;
		for (int i = 1; i < numPlayers; i++) {
			// update poisoned players
			if (playerActions[i][8] == 1) {
				playerActions[i][8] = 2;
			}
			// parasite action
			if (playerActions[i][0] == 26) {
				T1 = playerActions[i][3];
				// check that target is good
				if ((playerActions[T1][0] == 26) && (playerActions[T1][14] == 0)) {
					players[i].openPrivateChannel().flatMap(
							channel -> channel.sendMessage("You were unable to link to your target. Nothing happened."))
							.queue();
				} else if (playerActions[T1][14] != 0) {
					players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(
							"The player you targeted already has a parasite.\nIf any of you die, the others will also die."
									+ "\nYou now win the game with the following players:"))
							.queue();
					int id = playerActions[T1][14];
					String name = names[i];
					for (int j = 0; j < numPlayers; j++) {
						if (playerActions[j][14] == id) {
							int c = j;
							players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(names[c])).queue();

							players[j].openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("You have been linked with " + name
											+ ". Should this new Parasite die, both you and your partner will also die."))
									.queue(message -> message.addReaction(reactionKK).queue());
						}
					}
					playerActions[i][14] = id;
					playerActions[i][5] = 0;
				}
				// follow through
				else {
					playerActions[T1][14] = Link;
					playerActions[i][14] = Link;
					// make sure pairs are recorded
					Link++;
					String name1 = names[T1];
					String name2 = names[i];
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You have been linked with " + name1
									+ ". If one of you dies, the other will also die. "
									+ "\nYou now win the game with this person!"))
							.queue(message -> message.addReaction(reactionKK).queue());
					players[T1].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You have been linked with " + name2
									+ ". If one of you die, the other will also die. "
									+ "\nYou now win the game with this person!"))
							.queue(message -> message.addReaction(reactionKK).queue());
					playerActions[i][5] = 0;
				}
				T1 = 0;
			}
			// Bus Driver actions
			if (playerActions[i][0] == 6) {
				if (playerActions[i][2] != 2) {
					Swap1 = playerActions[i][3];
					Swap2 = playerActions[i][4];
					// Let targets know
					players[Swap1].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You were transported to another location"))
							.queue(message -> message.addReaction(reactionBl).queue());
					players[Swap2].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You were transported to another location"))
							.queue(message -> message.addReaction(reactionBl).queue());
				}
			}
			// Veteran actions
			if ((playerActions[i][0] == 5) && (playerActions[i][2] != 2)) {
				playerActions[i][5]--;
			}
			// amnesiac actions
			if (playerActions[i][0] == 25) {
				if ((playerActions[i][2] != 2) && (playerActions[i][13] != 1)) {
					T1 = playerActions[i][3];
					int v = 0;
					if ((playerActions[T1][0] == 6) || (playerActions[T1][0] == 12) || (playerActions[T1][0] == 13)
							|| (playerActions[T1][0] == 18) || (playerActions[T1][0] == 22)) {
						// checks if unique role is taken again
						for (int j = 1; j < numPlayers; j++) {
							if ((playerActions[j][1] == 1) && (playerActions[T1][0] == playerActions[j][0])) {
								players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(
										"Another Amesiac beat you to this role, your action didn't go through."))
										.queue();
								v = 1;
								break;
							}
						}
					}
					if (v == 0) {
						playerActions[i][0] = playerActions[T1][0];
						playerActions[i][2] = 2;
						playerActions[i][5] = 0;
						SendRole(i, 0);
						SendTeam(i);
						channel.sendTyping().queue();
						channel.sendMessage("The Amnesiac remembered that they were a(n) " + GetRole(i, 1) + "!")
								.queue(message -> message.addReaction(reactionKK).queue());
					}
					T1 = 0;
				}
			}
		}
		// Werewolf Actions
		for (int i = 1; i < numPlayers; i++) {
			if (playerActions[i][0] == 22) {
				// check if they are attacking
				if (playerActions[i][2] == 1) {
					// check target
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					int v = 0;
					// check for vet
					if ((playerActions[T1][0] == 5) && (playerActions[T1][2] == 1)) {
						LoopList[Loop] = i;
						TargetList[Loop] = T1;
						Loop++;
						v = 1;
					}
					// attack stuff
					if (v == 0) {
						wolf = i;
						wolfT = T1;
					}
				}
				// stays home to ambush
				else if (playerActions[i][3] == 2) {
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You stayed home to wait in ambush last night."))
							.queue();
				}
			}
			T1 = 0;
		}
		for (int i = 1; i < numPlayers; i++) {
			// Dancer and Concubine actions
			if ((playerActions[i][0] == 7) || (playerActions[i][0] == 14)) {
				if (playerActions[i][2] != 2) {
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					int v = 0;
					// check vet
					if ((playerActions[T1][0] == 5) && (playerActions[T1][2] == 1)) {
						LoopList[Loop] = i;
						TargetList[Loop] = T1;
						Loop++;
						v = 1;
					}
					for (int j = 1; j < numPlayers; j++) {
						// check ww
						if (((playerActions[j][0] == 22) && (playerActions[j][2] == 1) && (playerActions[j][3] == T1))
								|| ((playerActions[j][0] == 22) && (playerActions[j][2] == 2) && (j == T1))) {
							LoopList[Loop] = i;
							TargetList[Loop] = T1;
							Loop++;
							v = 1;
						}
					}
					if (v == 0) {
						playerActions[T1][12] = 1;
						if ((playerActions[T1][0] == 5) || (playerActions[T1][0] == 6) || (playerActions[T1][0] == 7)
								|| (playerActions[T1][0] == 22) || (playerActions[T1][0] == 14)) {
							players[T1].openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("Someone tried to roleblock you."))
									.queue(message -> message.addReaction(reactionBl).queue());
						} else
							players[T1].openPrivateChannel()
									.flatMap(channel -> channel
											.sendMessage("You were role blocked! Your action did not go through."))
									.queue(message -> message.addReaction(reactionBl).queue());
					}
					T1 = 0;
				}
			}
		}
		for (int i = 1; i < numPlayers; i++) {
			int v = 0;
			// Doctor actions
			if (playerActions[i][0] == 2) {
				if ((playerActions[i][2] != 2) && (playerActions[i][12] != 1)) {
					T1 = CheckSwap(i, Swap1, Swap2, 1);

					// check vet
					if ((playerActions[T1][0] == 5) && (playerActions[T1][2] == 1)) {
						LoopList[Loop] = i;
						TargetList[Loop] = T1;
						Loop++;
						v = 1;
					}
					for (int j = 1; j < numPlayers; j++) {
						// check ww
						if (((playerActions[j][0] == 22) && (playerActions[j][2] == 1) && (playerActions[j][3] == T1))
								|| ((playerActions[j][0] == 22) && (playerActions[j][2] == 2) && (j == T1))) {
							LoopList[Loop] = i;
							TargetList[Loop] = T1;
							Loop++;
							v = 1;
						}
					}
					if (v == 0)
						playerActions[i][3] = T1;
					else
						playerActions[i][2] = 2;
					v = 0;
					T1 = 0;
				}
			}
			// herbalist actions prt1
			else if (playerActions[i][0] == 10) {
				if ((playerActions[i][2] == 1) && (playerActions[i][12] != 1) && (playerActions[i][5] != 0)) {
					playerActions[i][5]--;
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					// check vet
					if ((playerActions[T1][0] == 5) && (playerActions[T1][2] == 1)) {
						LoopList[Loop] = i;
						TargetList[Loop] = T1;
						Loop++;
						v = 1;
					}
					for (int j = 1; j < numPlayers; j++) {
						// check ww
						if (((playerActions[j][0] == 22) && (playerActions[j][2] == 1) && (playerActions[j][3] == T1))
								|| ((playerActions[j][0] == 22) && (playerActions[j][2] == 2) && (j == T1))) {
							LoopList[Loop] = i;
							TargetList[Loop] = T1;
							Loop++;
							v = 1;
						}
					}
					if (v == 0)
						playerActions[i][3] = T1;
					else
						playerActions[i][2] = 3;
					v = 0;
					T1 = 0;
				}
			}
			// GA actions
			else if ((playerActions[i][0] == 27) && (playerActions[i][2] != 2) && (playerActions[i][12] != 1)) {
				playerActions[i][5]--;
				T1 = playerActions[i][3];
				playerActions[T1][7] = 1;
				players[T1].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("You have been blessed by your Guardian Angel!"))
						.queue(message -> message.addReaction(reactionBl).queue());
				T1 = 0;
			}
		}
		// finish up ww attack
		if (wolfT != 0) {
			if (CheckImmune(wolfT, wolf) == false) {
				players[wolfT].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("You were eaten by the Werewolf! You are dead."))
						.queue(message -> message.addReaction(reactionDe).queue());
				playerActions[wolfT][1] = 0;
				channel.sendTyping().queue();
				channel.sendMessage(names[wolfT] + " was eaten by the Werewolf!")
						.queue(message -> message.addReaction(reactionDe).queue());
				dead = 1;
				CheckLink(wolfT);
			}
		}
		// check above people for death
		for (int i = 0; i < Loop; i++) {
			if (LoopList[i] != 0) {
				CheckVet(TargetList[i], LoopList[i]);
			}
		}
		int mafioso = 0, orders = 0;
		// Godfather actions
		for (int i = 1; i < numPlayers; i++) {
			if (playerActions[i][0] == 12) {
				// check for mafioso
				for (int j = 1; j < numPlayers; j++) {
					if ((playerActions[j][0] == 13) && (playerActions[j][1] != 0)) {
						mafioso = j;
						break;
					}
				}
				// for mafioso orders
				if ((mafioso != 0) && (playerActions[i][2] != 2) && (playerActions[mafioso][12] != 1)) {
					orders = 1;
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					if ((CheckVet(T1, mafioso) == false) && (CheckImmune(T1, mafioso) == false)) {
						players[T1].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("You were killed by the Mafia! You are dead."))
								.queue(message -> message.addReaction(reactionDe).queue());
						playerActions[T1][1] = 0;
						channel.sendTyping().queue();
						channel.sendMessage(names[T1] + " was killed by the Mafia!")
								.queue(message -> message.addReaction(reactionDe).queue());
						dead = 1;
						CheckLink(T1);
					}
				} else if ((playerActions[i][2] != 2) && (playerActions[i][12] != 1)) {
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					if ((CheckVet(T1, i) == false) && (CheckImmune(T1, i) == false)) {
						players[T1].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("You were killed by the Mafia! You are dead."))
								.queue(message -> message.addReaction(reactionDe).queue());
						playerActions[T1][1] = 0;
						channel.sendTyping().queue();
						channel.sendMessage(names[T1] + " was killed by the Mafia!")
								.queue(message -> message.addReaction(reactionDe).queue());
						dead = 1;
						CheckLink(T1);
					}
				}
				break;
			}
			T1 = 0;
		}
		for (int i = 1; i < numPlayers; i++) {
			// Mafioso actions
			if (playerActions[i][0] == 13) {
				// check if mafioso can attack
				if (orders == 0) {
					if ((playerActions[i][2] != 2) && (playerActions[i][12] != 1)) {
						T1 = CheckSwap(i, Swap1, Swap2, 1);
						if ((CheckVet(T1, i) == false) && (CheckImmune(T1, i) == false)) {
							players[T1].openPrivateChannel().flatMap(
									channel -> channel.sendMessage("You were killed by the Mafia! You are dead."))
									.queue(message -> message.addReaction(reactionDe).queue());
							playerActions[T1][1] = 0;
							channel.sendTyping().queue();
							channel.sendMessage(names[T1] + " was killed by the Mafia!")
									.queue(message -> message.addReaction(reactionDe).queue());
							dead = 1;
							CheckLink(T1);
						}
					}
				}
				// stops attack if GF is in control
				else {
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("The Godfather ordered you to attack his target."))
							.queue();
				}
				T1 = 0;
			}
			// Framer actions
			if (playerActions[i][0] == 15) {
				if ((playerActions[i][2] != 2) && (playerActions[i][12] != 1)) {
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					if (CheckVet(T1, i) == false) {
						playerActions[T1][11] = 1;
					}
				}
				T1 = 0;
			}
		}
		// almost all other role actions are here
		for (int i = 1; i < numPlayers; i++) {
			switch (playerActions[i][0]) {
			// sheriff actions
			case 3:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					break;
				}
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				// check for framed target
				if (playerActions[T1][11] == 0) {
					if (playerActions[T1][10] == 1) {
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("Your target is an evil role!")).queue();
					} else
						players[i].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("Your target does not seem suspicious."))
								.queue();
				} else {
					playerActions[T1][11] = 2;
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Your target is an evil role!")).queue();
				}
				CheckVet(T1, i);
				T1 = 0;
				break;
			// vigilante actions
			case 4:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					break;
				}
				playerActions[i][5]--;
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				if ((CheckVet(T1, i) == false) && (CheckImmune(T1, i) == false)) {
					players[T1].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You were shot by the Vigilante! You are dead."))
							.queue(message -> message.addReaction(reactionDe).queue());
					playerActions[T1][1] = 0;
					channel.sendTyping().queue();
					channel.sendMessage(names[T1] + " was shot by the Vigilante!")
							.queue(message -> message.addReaction(reactionDe).queue());
					dead = 1;
					CheckLink(T1);
				}
				T1 = 0;
				break;
			// analyst actions
			case 8:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					break;
				}
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				T2 = CheckSwap(i, Swap1, Swap2, 2);
				// check for framed target
				if ((playerActions[T1][11] != 0) || (playerActions[T2][11] != 0)) {
					if (playerActions[T1][11] != 0)
						playerActions[T1][11] = 2;
					if (playerActions[T2][11] != 0)
						playerActions[T2][11] = 2;
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Your targets are on the same team.")).queue();
				}
				// check if targets are on the same team
				else if (playerActions[T1][15] == playerActions[T2][15]) {
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Your targets are on the same team.")).queue();
				} else
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("Your targets are not on the same team.")).queue();
				CheckVet(T1, i);
				CheckVet(T2, i);
				T1 = 0;
				T2 = 0;
				break;
			// herbalist part 2
			case 10:
				if ((playerActions[i][2] != 2) || (playerActions[i][12] == 1)) {
					break;
				}
				playerActions[i][5]--;
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				if ((CheckVet(T1, i) == false) && (CheckImmune(T1, i) == false)) {
					players[T1].openPrivateChannel()
							.flatMap(
									channel -> channel.sendMessage("You were murdered by the Herbalist! You are dead."))
							.queue(message -> message.addReaction(reactionDe).queue());
					playerActions[T1][1] = 0;
					channel.sendTyping().queue();
					channel.sendMessage(names[T1] + " was murdered by the Herbalist!")
							.queue(message -> message.addReaction(reactionDe).queue());
					dead = 1;
					CheckLink(T1);
				}
				T1 = 0;
				break;
			// polling officer actions
			case 11:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					playerActions[i][2] = 2;
					break;
				}
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				// target is added to voting list
				channel.sendTyping().queue();
				channel.sendMessage("The Polling Officer voted against " + names[T1] + "!")
						.queue(message -> message.addReaction(reactionKK).queue());
				voteList[Cr] = T1;
				counterList[Cr] = 1;
				Cr++;
				T1 = 0;
				break;
			// Jester actions
			case 24:
				if (playerActions[i][5] == 2) {
					playerActions[i][5]--;
					T1 = playerActions[i][3];
					players[T1].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You were haunted by the Jester! You are dead."))
							.queue(message -> message.addReaction(reactionDe).queue());
					playerActions[T1][1] = 0;
					channel.sendTyping().queue();
					channel.sendMessage(names[T1] + " was haunted by the Jester!")
							.queue(message -> message.addReaction(reactionDe).queue());
					dead = 1;
					CheckLink(T1);
					T1 = 0;
				}
				break;
			// Serial Killer actions
			case 21:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					break;
				}
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				if ((CheckVet(T1, i) == false) && (CheckImmune(T1, i) == false)) {
					players[T1].openPrivateChannel().flatMap(
							channel -> channel.sendMessage("You were murdered by the Serial Killer! You are dead."))
							.queue(message -> message.addReaction(reactionDe).queue());
					playerActions[T1][1] = 0;
					channel.sendTyping().queue();
					channel.sendMessage(names[T1] + " was murdered by the Serial Killer!")
							.queue(message -> message.addReaction(reactionDe).queue());
					dead = 1;
					CheckLink(T1);
				}
				T1 = 0;
				break;
			// Arsonist actions
			case 20:
				if ((playerActions[i][2] == 3) || (playerActions[i][12] == 1)) {
					break;
				}
				// if Arsonist ignites
				if (playerActions[i][2] == 2)
					playerActions[i][3] = i;
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				if ((playerActions[i][2] == 2) && (CheckVet(T1, i) == false)) {
					// all doused targets die
					for (int j = 1; j < numPlayers; j++) {
						if ((playerActions[j][9] == 1) && (playerActions[j][1] == 1)) {
							players[j].openPrivateChannel().flatMap(
									channel -> channel.sendMessage("You were burned by the Arsonist! You are dead."))
									.queue(message -> message.addReaction(reactionDe).queue());
							playerActions[j][1] = 0;
							channel.sendTyping().queue();
							channel.sendMessage(names[j] + " was burned by the Arsonist!")
									.queue(message -> message.addReaction(reactionDe).queue());
							dead = 1;
							CheckLink(j);
						}
					}
				} else if (CheckVet(T1, i) == false)
					playerActions[T1][9] = 1;
				T1 = 0;
				break;
			// Barman actions
			case 23:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					break;
				}
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				// starts player countdown to death
				if ((CheckVet(T1, i) == false) && (playerActions[T1][8] == 0)) {
					playerActions[T1][8] = 1;
					players[T1].openPrivateChannel().flatMap(channel -> channel.sendMessage("You were "
							+ "poisoned by the Barman. If you are not healed by the following day, you will die!"))
							.queue();
				}
				T1 = 0;
				break;
			// Inside-Man actions
			case 16:
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					break;
				}
				playerActions[i][5]--;
				T1 = CheckSwap(i, Swap1, Swap2, 1);
				// target is unable to be voted
				playerActions[T1][13] = 1;
				channel.sendTyping().queue();
				channel.sendMessage(names[T1] + " cannot be voted for today!").queue();
				T1 = 0;
				break;
			}
		}
		// Head Vampire actions
		for (int i = 1; i < numPlayers; i++) {
			if (playerActions[i][0] == 18) {
				if ((playerActions[i][2] == 2) || (playerActions[i][12] == 1)) {
					if (playerActions[i][5] == 0)
						playerActions[i][5] = 1;
					break;
				} else {
					T1 = CheckSwap(i, Swap1, Swap2, 1);
					// vampire tries to bite target
					if ((CheckVet(T1, i) == false) && (CheckImmune(T1, i) == false)) {
						// does target die from bite?
						if ((playerActions[T1][0] == 13) || (playerActions[T1][0] == 14) || (playerActions[T1][0] == 15)
								|| (playerActions[T1][0] == 16) || (playerActions[T1][0] == 17)) {
							players[T1].openPrivateChannel().flatMap(
									channel -> channel.sendMessage("You were murdered by a Vampire! You are dead."))
									.queue(message -> message.addReaction(reactionDe).queue());
							playerActions[T1][1] = 0;
							channel.sendTyping().queue();
							channel.sendMessage(names[T1] + " was murdered by a Vampire!")
									.queue(message -> message.addReaction(reactionDe).queue());
							dead = 1;
							CheckLink(T1);
						} else if ((playerActions[T1][0] == 18) || (playerActions[T1][0] == 19)) {
							players[i].openPrivateChannel()
									.flatMap(channel -> channel
											.sendMessage("You tried to bite a fellow Vampire, it was very awkward."))
									.queue();
							players[T1].openPrivateChannel()
									.flatMap(channel -> channel
											.sendMessage("A fellow Vampire tried to bite you, it was very awkward."))
									.queue();
						} else {
							playerActions[T1][0] = 19;
							playerActions[i][5] = 0;
							SendRole(T1, 0);
							players[T1].openPrivateChannel()
									.flatMap(channel -> channel
											.sendMessage("You were bitten by a Vampire! You are now a Turned Vampire."))
									.queue();
							SendTeam(i);
						}
					}
				}
				T1 = 0;
				break;
			}
		}
		// update poison
		for (int i = 1; i < numPlayers; i++) {
			if ((playerActions[i][8] == 1) || (playerActions[i][8] == 2)) {
				// check for GA
				if (playerActions[i][7] == 1) {
					playerActions[i][8] = 0;
					players[i].openPrivateChannel().flatMap(
							channel -> channel.sendMessage("You were saved from the poison by your Guardian Angel!"))
							.queue(message -> message.addReaction(reactionHe).queue());
				}
				// check for healer
				for (int j = 1; j < numPlayers; j++) {
					if (((playerActions[j][0] == 2) && (playerActions[j][2] == 1))
							|| ((playerActions[j][0] == 10) && (playerActions[j][2] == 1))) {
						if (playerActions[j][3] == i) {
							playerActions[i][8] = 0;
							players[i].openPrivateChannel().flatMap(
									channel -> channel.sendMessage("You were saved from the poison by a Healer!"))
									.queue(message -> message.addReaction(reactionHe).queue());
							players[j].openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("You saved your target from death!"))
									.queue(message -> message.addReaction(reactionHe).queue());
						}
					}
				}
				// check if they are dead
				if (playerActions[i][8] == 2) {
					players[i].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("The Barman's poison was not cured! You are dead."))
							.queue(message -> message.addReaction(reactionDe).queue());
					dead = 1;
					playerActions[i][1] = 0;
					channel.sendTyping().queue();
					channel.sendMessage(names[i] + " was killed by the Barman!")
							.queue(message -> message.addReaction(reactionDe).queue());
					CheckLink(i);
				}
			}
		}
		// clean up and reset
		CheckUpgrade();
		if (dead == 0) {
			channel.sendTyping().queue();
			channel.sendMessage("No one died last night").queue(message -> message.addReaction(reactionNd).queue());
		}
		for (int i = 1; i < numPlayers; i++) {
			LoopList[i] = 0;
			TargetList[i] = 0;
			if (playerActions[i][11] == 2)
				playerActions[i][11] = 0;
			playerActions[i][12] = 0;
			if (playerActions[i][0] == 22)
				playerActions[i][10] = 0;
			if (playerActions[i][1] == 0) {
				playerActions[i][16] = 1;
			}
			if ((playerActions[i][0] != 2) && (playerActions[i][0] != 27) && (playerActions[i][0] != 28)) {
				playerActions[i][3] = 0;
			}
			playerActions[i][4] = 0;
			if ((playerActions[i][0] == 10) || (playerActions[i][0] == 20) || (playerActions[i][0] == 22)) {
				playerActions[i][2] = 3;
				// leaves Polling officer as is for voting total count
			} else if (playerActions[i][0] != 11) {
				playerActions[i][2] = 2;
			}
			if (playerActions[i][1] == 0)
				roleList[i] = 0;
		}
	}

	public boolean CheckHunter() {
		int c = 0;
		// check if hunter has died function
		for (int i = 1; i < numPlayers; i++) {
			if ((playerActions[i][0] == 9) && (playerActions[i][1] == 0) && (playerActions[i][5] == 1)) {
				players[i].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("Please enter who you would like to kill"
								+ " using \"$kill\", with the target number following."))
						.queue();
				// tells them who is alive
				EmbedBuilder alive = LiveList();
				players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(alive.build())).queue();
				channel.sendTyping().queue();
				channel.sendMessage(names[i] + " was the Hunter, they will now choose a target to kill!")
						.queue(message -> message.addReaction(reactionKK).queue());
				c = 1;
			}
		}
		if ((c != 0))
			return true;
		else
			return false;
	}

	public boolean CheckVet(int Target, int Origin) {
		// check for vet target
		if ((playerActions[Target][0] == 5) && (playerActions[Target][2] == 1)) {
			// check for GA
			players[Target].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("You shot someone who visited you!")).queue();
			// check ga
			if (playerActions[Origin][7] == 1) {
				players[Origin].openPrivateChannel().flatMap(
						channel -> channel.sendMessage("You were saved from the Veteran by your Guardian Angel!"))
						.queue(message -> message.addReaction(reactionHe).queue());
				return true;
			}
			// check for healer
			for (int j = 1; j < numPlayers; j++) {
				if (((playerActions[j][0] == 2) && (playerActions[j][2] == 1))
						|| ((playerActions[j][0] == 10) && (playerActions[j][2] == 1))) {
					if (playerActions[j][3] == Origin) {
						players[Origin].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("You were saved from the Veteran by a Healer!"))
								.queue(message -> message.addReaction(reactionHe).queue());
						players[j].openPrivateChannel()
								.flatMap(channel -> channel.sendMessage("You saved your target from death!"))
								.queue(message -> message.addReaction(reactionHe).queue());
						return true;
					}
				}
			}
			// they're dead
			players[Origin].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("You were killed by the Veteran! You are dead."))
					.queue(message -> message.addReaction(reactionDe).queue());
			playerActions[Origin][1] = 0;
			channel.sendTyping().queue();
			channel.sendMessage(names[Origin] + " was killed by the Veteran!")
					.queue(message -> message.addReaction(reactionDe).queue());
			dead = 1;
			CheckLink(Origin);
			return true;
		}
		// check for ww senanigans
		for (int i = 1; i < numPlayers; i++) {
			// check for ww target
			if (((playerActions[i][0] == 22) && (playerActions[i][2] == 1) && (playerActions[i][3] == Target))
					|| ((playerActions[i][0] == 22) && (playerActions[i][2] == 2) && (i == Target))) {
				// check for GA
				if (playerActions[Origin][7] == 1) {
					players[Origin].openPrivateChannel().flatMap(
							channel -> channel.sendMessage("You were saved from the Werewolf by your Guardian Angel!"))
							.queue(message -> message.addReaction(reactionHe).queue());
					return true;
				}
				// check for healer
				for (int j = 1; j < numPlayers; j++) {
					if (((playerActions[j][0] == 2) && (playerActions[j][2] == 1))
							|| ((playerActions[j][0] == 10) && (playerActions[j][2] == 1))) {
						if (playerActions[j][3] == Origin) {
							players[Origin].openPrivateChannel().flatMap(
									channel -> channel.sendMessage("You were saved from the Werewolf by a Healer!"))
									.queue(message -> message.addReaction(reactionHe).queue());
							players[j].openPrivateChannel()
									.flatMap(channel -> channel.sendMessage("You saved your target from death!"))
									.queue(message -> message.addReaction(reactionHe).queue());
							return true;
						}
					}
				}
				// check for immune
				if (playerActions[Origin][6] == 1) {
					players[Origin].openPrivateChannel()
							.flatMap(channel -> channel
									.sendMessage("Someone tried to attack you, but you were immune to their attack."))
							.queue(message -> message.addReaction(reactionKK).queue());
					return true;
				}
				// they're dead
				players[Origin].openPrivateChannel()
						.flatMap(channel -> channel.sendMessage("You were eaten by the Werewolf! You are dead."))
						.queue(message -> message.addReaction(reactionDe).queue());
				playerActions[Origin][1] = 0;
				channel.sendTyping().queue();
				channel.sendMessage(names[Origin] + " was eaten by the Werewolf!")
						.queue(message -> message.addReaction(reactionDe).queue());
				dead = 1;
				CheckLink(Origin);
				return true;
			}
		}
		return false;
	}

	public int CheckSwap(int Origin, int Swap1, int Swap2, int slot) {
		// check for swap function
		int T;
		// checks first target for swap
		if (slot == 1) {
			if (playerActions[Origin][3] == Swap1)
				T = Swap2;
			else if (playerActions[Origin][3] == Swap2)
				T = Swap1;
			else
				T = playerActions[Origin][3];
		}
		// check second target for swap
		else {
			if (playerActions[Origin][4] == Swap1)
				T = Swap2;
			else if (playerActions[Origin][4] == Swap2)
				T = Swap1;
			else
				T = playerActions[Origin][4];
		}
		return T;
	}

	public void CheckLink(int Origin) {
		// check for parasite function
		if (playerActions[Origin][14] != 0) {
			// records parasite ID
			int id = playerActions[Origin][14];
			for (int j = 1; j < numPlayers; j++) {
				// kills anyone with that ID
				if (playerActions[j][14] == id) {
					players[j].openPrivateChannel().flatMap(
							channel -> channel.sendMessage("You were killed from a heart complication! You are dead."))
							.queue(message -> message.addReaction(reactionBr).queue());
					playerActions[j][1] = 0;
					channel.sendTyping().queue();
					channel.sendMessage(names[j] + " was killed by a heart complication!")
							.queue(message -> message.addReaction(reactionBr).queue());
				}
			}
		}
	}

	public boolean CheckImmune(int Target, int Origin) {
		// check for immune or healed targets function
		// check for GA
		int v = 0;
		if (playerActions[Target][7] == 1) {
			players[Target].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("You were saved by your Guardian Angel!"))
					.queue(message -> message.addReaction(reactionHe).queue());
			players[Origin].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("Your target was immune to your attack!"))
					.queue(message -> message.addReaction(reactionKK).queue());
			v = 1;
		}
		// check for healer
		for (int j = 1; j < numPlayers; j++) {
			if (((playerActions[j][0] == 2) && (playerActions[j][2] == 1))
					|| ((playerActions[j][0] == 10) && (playerActions[j][2] == 1))) {
				if (playerActions[j][3] == Target) {
					players[Target].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You were saved by a Healer!"))
							.queue(message -> message.addReaction(reactionHe).queue());
					players[j].openPrivateChannel()
							.flatMap(channel -> channel.sendMessage("You saved your target from death!"))
							.queue(message -> message.addReaction(reactionHe).queue());
					v = 1;
				}
			}
		}
		// check for immune
		if (playerActions[Target][6] == 1) {
			players[Target].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("Someone tried to kill you, but you were immune."))
					.queue(message -> message.addReaction(reactionKK).queue());
			players[Origin].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("Your target was immune to your attack!"))
					.queue(message -> message.addReaction(reactionKK).queue());
			v = 1;
		}
		if (v == 1)
			return true;
		else
			return false;
	}

	// These Functions Send Role Stuff
	// send role name function
	public String GetRole(int i, int who) {
		int u = 0;
		// sends roles based on exact info for setup
		if (setup == true)
			u = i;
		// sends roles based character info
		else if (who == 1)
			u = playerActions[i][0];
		// sends roles based on list results
		else
			u = (List[i]);
		switch (u) {
		// town roles
		case 1:
			return "Civilian";
		case 2:
			return "Doctor";
		case 3:
			return "Sheriff";
		case 4:
			return "Vigilante";
		case 5:
			return "Veteran";
		case 6:
			return "Bus Driver";
		case 7:
			return "Dancer";
		case 8:
			return "Analyst";
		case 9:
			return "Hunter";
		case 10:
			return "Herbalist";
		case 11:
			return "Polling Officer";
		case 12:
			return "Godfather";
		case 13:
			return "Mafioso";
		case 14:
			return "Concubine";
		case 15:
			return "Framer";
		case 16:
			return "Inside Man";
		case 17:
			return "Mafia Member";
		case 18:
			return "Head Vampire";
		case 19:
			return "Turned Vampire";
		case 20:
			return "Arsonist";
		case 21:
			return "Serial Killer";
		case 22:
			return "Werewolf";
		case 23:
			return "Barman";
		case 24:
			return "Jester";
		case 25:
			return "Amnesiac";
		case 26:
			return "Parasite";
		case 27:
			return "Guardian Angel";
		case 28:
			return "Bounty Hunter";
		// in case number is called that isn't here
		default:
			return "error " + u;
		}
	}

	// send role cards function
	public void SendRole(int i, int help) {
		switch (playerActions[i][0]) {
		// town roles
		case 1:
			EmbedBuilder role = new EmbedBuilder().setTitle("Civilian (Town)").setDescription("Possible Actions: None")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 2:
			role = new EmbedBuilder().setTitle("Doctor (Town)")
					.setDescription("Possible Actions: \n(1) Heal a player\n(2) Do nothing\n"
							+ "(You cannot heal the same target twice in a row)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 3:
			role = new EmbedBuilder().setTitle("Sheriff (Town)")
					.setDescription("Possible Actions: \n(1) Investigate another player\n(2) Do nothing")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 4:
			role = new EmbedBuilder().setTitle("Vigilante (Town)")
					.setDescription("Possible Actions: \n(1) Shhot another player\n(2) Do nothing\n"
							+ "(You can only shoot 1 (2 for 12 or more players) times total)\n(You cannot shoot night 1)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				if (numPlayers >= 12)
					playerActions[i][5] = 2;
				else
					playerActions[i][5] = 1;
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 5:
			role = new EmbedBuilder().setTitle("Veteran (Town)")
					.setDescription("Possible Actions: \n(1) Activate self-defence\n(2) Do nothing"
							+ "\n(kill anyone who visits you, you can only activate 2 (3 for 12 or more people) times)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				if (numPlayers >= 12)
					playerActions[i][5] = 3;
				else
					playerActions[i][5] = 2;
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 6:
			role = new EmbedBuilder().setTitle("Bus Driver (Town)")
					.setDescription("Possible Actions: \n(1) Make two people swap places\n(2) Do nothing"
							+ "\n(What would happen to one, instead happens to the other)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 7:
			role = new EmbedBuilder().setTitle("Dancer (Town)")
					.setDescription("Possible Actions: \n(1) Distract target player\n(2) Do nothing"
							+ "\n(You block target player's action)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 8:
			role = new EmbedBuilder().setTitle("Analyst (Town)")
					.setDescription("Possible Actions: \n(1) Select two players for a connection"
							+ "\n(2) Do nothing\n(You cannot select yourself)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 9:
			role = new EmbedBuilder().setTitle("Hunter (Town)")
					.setDescription("Possible Actions: None\n(Upon your death, you take another player with you)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][5] = 1;
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 10:
			role = new EmbedBuilder().setTitle("Herbalist (Town)")
					.setDescription("Possible Actions: \n(1) Save target player\n(2) Kill target player"
							+ "\n(3) Do nothing\n(You can only do 2 (3 for 10 or more players) abilities throughout the game)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				if (numPlayers >= 10)
					playerActions[i][5] = 3;
				else
					playerActions[i][5] = 2;
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 11:
			role = new EmbedBuilder().setTitle("Polling Officer (Town)")
					.setDescription("Possible Actions: \n(1) Place a vote on another player\n(2) Do nothing"
							+ "\n(This is separate from your daytime vote)")
					.setFooter("Goal: Survive", null).setColor(0x90ee90);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 1;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		// Mafia roles
		case 12:
			role = new EmbedBuilder().setTitle("Godfather (Mafia, Evil)")
					.setDescription("Possible Actions: \n(1) Target player is killed by the killing role in "
							+ "the mafia\n(2) Do nothing\n(You are immune to basic attacks and come up as innocent to the Sheriff)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFF0000);
			if (help != 1) {
				playerActions[i][6] = 1;
				playerActions[i][10] = 0;
				playerActions[i][15] = 2;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 13:
			role = new EmbedBuilder().setTitle("Mafioso (Mafia, Evil)").setDescription(
					"Possible Actions: \n(1) Kill target player\n(2) Do nothing\n(If there is a Godfather, "
							+ "they get the final say about who you target)\n(If your Godfather dies, you become the Godfather)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFF0000);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 2;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 14:
			role = new EmbedBuilder().setTitle("Concubine (Mafia, Evil)").setDescription(
					"Possible Actions: \n(1) Distract target player\n(2) Do nothing\n(You block target player's action)"
							+ "\n(If your Mafioso dies, you might become the Mafioso if no one else can)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFF0000);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 2;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 15:
			role = new EmbedBuilder().setTitle("Framer (Mafia, Evil)").setDescription(
					"Possible Actions: \n(1) Frame target player\n(2) Do nothing\n(You sabotage the town's investigators)"
							+ "\n(If your Mafioso dies, you might become the Mafioso if no one else can)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFF0000);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 2;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 16:
			role = new EmbedBuilder().setTitle("Inside Man (Mafia, Evil)")
					.setDescription("Possible Actions: \n(1) Give target player immunity to voting\n(2) Do nothing"
							+ "\n(You can protect someone (2 or 3) times)"
							+ "\n(If your Mafioso dies, you might become the Mafioso if no one else can)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFF0000);
			if (help != 1) {
				if (numPlayers >= 12)
					playerActions[i][5] = 3;
				else
					playerActions[i][5] = 2;
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 2;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 17:
			role = new EmbedBuilder().setTitle("Mafia Member (Mafia, Evil)")
					.setDescription("Possible Actions: None \n(If your Mafioso dies, you might become the Mafioso)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFF0000);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 2;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		// Vampires
		case 18:
			role = new EmbedBuilder().setTitle("Head Vampire (Vampire, Evil)")
					.setDescription("Possible Actions: \n(1) Bite target player\n(2) Do nothing\n(They are converted "
							+ "into a Turned Vampire if it is possible) "
							+ "\n(They will either die if they are not convertible or they are immune)")
					.setFooter("Goal: Kill / convert everyone", null).setColor(0xA9A9A9);
			if (help != 1) {
				playerActions[i][5] = 1;
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 4;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 19:
			role = new EmbedBuilder().setTitle("Turned Vampire (Vampire, Evil)")
					.setDescription(
							"Possible Actions: None\n(If your Head Vampire dies, you might become the Head Vampire)")
					.setFooter("Goal: Kill / convert everyone", null).setColor(0xA9A9A9);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 4;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		// selfish killing
		case 20:
			role = new EmbedBuilder().setTitle("Arsonist (Selfish Killing, Evil)")
					.setDescription(
							"Possible Actions: \n(1) Douse target player\n(2) Burn all doused players\n(3) Do nothing"
									+ "\n(You are immune to basic attacks and come up as innocent to the Sheriff)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0xFFA500);
			if (help != 1) {
				playerActions[i][2] = 3;
				playerActions[i][6] = 1;
				playerActions[i][10] = 0;
				playerActions[i][15] = 3;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 21:
			role = new EmbedBuilder().setTitle("Serial Killer (Selfish Killing, Evil)")
					.setDescription("Possible Actions: \n(1) Kill target player\n(2) Do nothing"
							+ "\n(You are immune to basic attacks)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0x0000ff);
			if (help != 1) {
				playerActions[i][6] = 1;
				playerActions[i][10] = 1;
				playerActions[i][15] = 3;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 22:
			role = new EmbedBuilder().setTitle("Werewolf (Selfish Killing, Evil)").setDescription(
					"Possible Actions: \n(1) Kill target player\n(2) Ambush visitors at home\n(3) Do nothing"
							+ "\n(You can only attack on full moons)\n(Any player visiting your target will also die)"
							+ "\n(You are immune to basic attacks)")
					.setFooter("Goal: Kill all town / enemy evils", null).setColor(0x654321);
			if (help != 1) {
				playerActions[i][2] = 3;
				playerActions[i][6] = 1;
				playerActions[i][10] = 0;
				playerActions[i][15] = 3;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		// neutral killing
		case 23:
			role = new EmbedBuilder().setTitle("Barman (Neutral killing, Evil)")
					.setDescription("Possible Actions: \n(1) Poison target player \n(2) Do nothing"
							+ "\n(Targets die the following day if they are not healed)")
					.setFooter("Goal: Kill all town / any evils of your choice", null).setColor(0x808000);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 6;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		// neutral passive
		case 24:
			role = new EmbedBuilder().setTitle("Jester (Neutral Passive, Evil)")
					.setDescription(
							"Possible Actions: None\n(You get to kill someone if you are voted off by the town)")
					.setFooter("Goal: Get voted off by the town during the day", null).setColor(0xb19cd9);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 1;
				playerActions[i][15] = 5;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 25:
			role = new EmbedBuilder().setTitle("Amnesiac (Neutral Passive)")
					.setDescription("Possible Actions: \n(1) Become the role of a dead player\n(2) Do nothing")
					.setFooter("Goal: None (gain a goal from who you become)", null).setColor(0xadd8e6);
			if (help != 1) {
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 5;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 26:
			role = new EmbedBuilder().setTitle("Parasite (Neutral Passive)")
					.setDescription(
							"Possible Actions: \n(1) Link to another player at the start of the game\n(2) Do nothing"
									+ "\n(If you or your host dies, you both die)")
					.setFooter("Goal: Survive with your host", null).setColor(0xF5F5DC);
			if (help != 1) {
				playerActions[i][5] = 1;
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 5;
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			break;
		case 27:
			role = new EmbedBuilder().setTitle("Guardian Angel (Neutral Passive)")
					.setDescription("Possible Actions: \n(1) Protect your given target from all incoming damage "
							+ "\n(2) Do nothing\n(You can protect them 2 (3 for 12 or more players) times, "
							+ "you can protect them even if you are dead)\n(If they die, you become a basic version of their role)")
					.setFooter("Goal: Your target survives", null).setColor(0xFFFFFF);
			if (help != 1) {
				if (numPlayers >= 14)
					playerActions[i][5] = 3;
				else
					playerActions[i][5] = 2;
				playerActions[i][6] = 0;
				playerActions[i][10] = 0;
				playerActions[i][15] = 5;
				int o = 420;
				do {
					playerActions[i][3] = (int) (Math.random() * ((numPlayers - 1) + 1)) + 1;
					if ((playerActions[i][3] != i) && (playerActions[i][3] < numPlayers)
							&& (playerActions[playerActions[i][3]][1] == 1)
							&& (playerActions[playerActions[i][3]][0] != 24))
						o = 69;
				} while (o == 420);
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			players[i].openPrivateChannel()
					.flatMap(channel -> channel.sendMessage("You must protect: " + names[playerActions[i][3]] + " ("
							+ playerActions[i][3] + ")\nThey are a(n) " + GetRole(playerActions[i][3], 1)))
					.queue();
			break;
		case 28:
			role = new EmbedBuilder().setTitle("Bounty Hunter (Neutral Passive)")
					.setDescription("Possible Actions: None\n(Get your target voted off during the day)"
							+ "(You are immune to basic attacks)\n(If they die at night, you become a Jester)")
					.setFooter("Goal: Get your target voted off at any cost", null).setColor(0xC0C0C0);
			if (help != 1) {
				playerActions[i][6] = 1;
				playerActions[i][10] = 0;
				playerActions[i][15] = 5;
				int y = 420;
				do {
					playerActions[i][3] = (int) (Math.random() * ((numPlayers - 1) + 1)) + 1;
					if ((playerActions[i][3] != i) && (playerActions[i][3] < numPlayers)
							&& (playerActions[playerActions[i][3]][1] == 1))
						y = 69;
				} while (y == 420);
			}
			players[i].openPrivateChannel().flatMap(channel -> channel.sendMessage(role.build())).queue();
			players[i].openPrivateChannel().flatMap(channel -> channel
					.sendMessage("You must kill: " + names[playerActions[i][3]] + " (" + playerActions[i][3] + ")"))
					.queue();
			break;
		// in case number is called that isn't here
		default:
			channel.sendTyping().queue();
			channel.sendMessage("Error: " + playerActions[i][0]).queue();
			break;
		}
	}
}
